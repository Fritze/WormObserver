# Use this script after running the "data_grouping.R" script that summarises the data for a given condition.
# Needed: A metadata file that is located in the folder that contains the "raw_data.RDS" files generated by the "data_grouping.R" (i.e. the directory that contains the acquired experiments)
# This file should be named "toprocess_motion.txt" and contain the conditions you want to analyse.
# Additionally you have to specify the conversion factor (the number of micrometers that correspond to one pixel at your given magnification, i.e. 6.25).

# To run the script type: Rscript motion.R "the location of your raw data folder" "conversion factor" 
# e.g. Rscript motion.R /media/fpreuss/raid5/timelapses/analysis/paper/raw 6.25

library("tidyverse")
library("reshape2")

############### functions ###############

# 1 small helper functions
# used to calculate distance change for estimating speed
distance <- function(x1, y1, x2, y2) {
  values <- list(x1, y1, x2, y2)
  if(anyNA(values)) {
    "NA"
  } else {
    length <- sqrt((x1-x2)^2+(y1-y2)^2)
    as.numeric(length)
  }
}
# the function which will change all values of a given column to NA, except those rows that are consecutive for y times
replace_f <- function(x,y){
  subs <- rle(x)
  subs$values[subs$lengths < y] <- NA
  inverse.rle(subs)
}


# 2 skeleton functions
skeleton_direction <- function(x){
  mutate(x,x_lag=lag(location_x,n=1) - location_x, y_lag = lag(location_y, n=1) - location_y) %>%
    mutate(x_lead=lead(location_x, n=1) - location_x, y_lead=lead(location_y, n=1) - location_y) %>%
    #calculate local distance for velocity (difference between position n and position n-1 second (i.e. 2 frames))
    mutate(local_distance=suppressWarnings(as.numeric(mapply(distance,lag(location_x,n=2),lag(location_y,n=2),location_x,location_y)))) %>%
    # this will result in velocity based on local distance (µm/s)
    mutate(velocity = local_distance*conversion_factor/downsampled_to) %>%
    mutate(x_dir = ifelse(x_lead < 0, "left","right")) %>%
    mutate(y_dir = ifelse(y_lead < 0, "up","down")) %>%
    mutate(direction = paste(x_dir,y_dir,sep="-")) %>%
    mutate(direction = ifelse(velocity > 10,direction, NA)) %>%
    #only keep the direction when direction and speed > 10µm/s is stable over 2.5 seconds
    mutate(direction = replace_f(direction,5))
  
}

# this function is adapted from the skeleton frame function
# but it just counts number of pixels of the midline of the worm, if skeleton is unclear, no count
count_midline_pixels <- function(data){
  #get dimension from table, variables bitmask_dim_Y and bitmask_dim_X
  dim_Y <- data$bitmask_dim_Y
  dim_X <- data$bitmask_dim_X
  # #import the data from bitmask column and transform to matrix with right dimensions
  bitmask <- data$bitmask
  bitmask <- strsplit(as.character(unlist(bitmask)),",")
  bitmask <- as.numeric(unlist(lapply(bitmask,gsub,pattern=".*(\\d+)\\..+", replacement="\\1")))
  data_imported <- matrix(bitmask,nrow=dim_Y, byrow=TRUE)
  
  # #add 2 columns and 2 frames (as a "frame" around the bitmask)
  data_imported <- rbind(data_imported, rep(0,ncol(data_imported)))
  data_imported <- rbind(rep(0,ncol(data_imported)),data_imported)
  data_imported <- cbind(rep(0, nrow(data_imported)),data_imported)
  data_imported <- cbind(data_imported,rep(0, nrow(data_imported)))
  #
  #
  #add two to get the new dimensions right
  dim_X <- data$bitmask_dim_X + 2
  dim_Y <- data$bitmask_dim_Y + 2
  
  data_imported <- data_imported %>%
    melt(.) %>%
    rename(Y = 1, X = 2,value = 3) %>%
    mutate(next_px_1_x = 0, next_px_1_y = 0,
           next_px_2_x = 0, next_px_2_y = 0)
  
  
  # this is a ggplot to check if the skeleton was imported right
  # ggplot(data_imported %>% filter(value==1), aes(x=X,y=Y))+
  #   coord_equal() +
  #   geom_tile(fill="red",color="black") +
  #   scale_x_continuous(expand = c(0, 0), limits= c(0,dim_X)) +
  #   scale_y_continuous(expand = c(0, 0),trans="reverse") +
  #   theme(legend.position="none")+
  #   ggsave("test.png")
  
  pixel_list <- vector(mode="list",length=0)
  rows_with_value1 <- data_imported %>%
    mutate(original_rownumber=1:n()) %>%
    filter(value == 1) %>%
    pull(original_rownumber)
  
  
  for(i in rows_with_value1){
    
    #look for surrounding pixels of those pixels that have value == 1
    if(data_imported[i+1,"value"] == 1){#0°
      pixel_list <- append(pixel_list,paste(data_imported[i+1,"X"],data_imported[i+1,"Y"], sep=","))}
    if(data_imported[i+dim_Y+1,"value"] == 1){#45°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y+1,"X"],data_imported[i+dim_Y+1,"Y"], sep=","))}
    if(data_imported[i+dim_Y,"value"] == 1){#90°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y,"X"],data_imported[i+dim_Y,"Y"], sep=","))}
    if(data_imported[i+dim_Y-1,"value"] == 1){#135°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y-1,"X"],data_imported[i+dim_Y-1,"Y"], sep=","))}
    if(data_imported[i-1,"value"] == 1){#180°
      pixel_list <- append(pixel_list,paste(data_imported[i-1,"X"],data_imported[i-1,"Y"], sep=","))}
    if(data_imported[i-dim_Y-1,"value"] == 1){#225°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y-1,"X"],data_imported[i-dim_Y-1,"Y"], sep=","))}
    if(data_imported[i-dim_Y,"value"] == 1){#270°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y,"X"],data_imported[i-dim_Y,"Y"], sep=","))}
    if(data_imported[i-dim_Y+1,"value"] == 1){#315°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y+1,"X"],data_imported[i-dim_Y+1,"Y"], sep=","))}
    
    
    #if only one neighbouring pixel is found then it most likely corresponds to the end (head or tail of the worm)
    if(length(pixel_list) == 1 ){
      data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
      data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
      data_imported[i,"is_end"] <- "YES"
      pixel_list <- vector(mode="list",length=0)
      #if there are more than one neighbouring pixels than the pixel in question sits somewhere in the middle
      #so far we only account for more than  two neighbours ...
    } else if(length(pixel_list) > 1){
      data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
      data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
      data_imported[i,"next_px_2_x"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[1])
      data_imported[i,"next_px_2_y"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[2])
      data_imported[i,"is_end"] <- "NO"
      pixel_list <- vector(mode="list",length=0)
    }
  }
  
  
  
  # if there is no pixel found with any neighbours set all pixels to is_end == "NO"
  if (is.null(data_imported$is_end)){
    data_imported$is_end <- "NO"
  }
  
  data_w_angles <- data_imported %>%
    #only pixels that have value 1 (== no background)
    filter(value == 1) %>%
    #make sure that one endpoint is at the top of the table
    arrange(desc(is_end)) %>%
    #group positions (actual and neighbouring ones to one string)
    mutate(pos = paste(X,Y,sep=",")) %>%
    mutate(next_pos_1 = paste(next_px_1_x,next_px_1_y,sep=",")) %>%
    mutate(next_pos_2 = paste(next_px_2_x,next_px_2_y,sep=",")) %>%
    mutate(direction = data$direction) %>%
    mutate(direction = ifelse(is.na(direction), "no direction",direction)) %>%
    mutate(x_dir = data$x_dir) %>%
    mutate(x_dir = ifelse(is.na(x_dir), "no direction",x_dir)) %>%
    mutate(y_dir = data$y_dir) %>%
    mutate(y_dir = ifelse(is.na(y_dir), "no direction",y_dir)) %>%
    mutate(location_x = data$location_x) %>%
    mutate(location_y =data$location_y) %>%
    select(-c(next_px_1_x,next_px_1_y,next_px_2_x,next_px_2_y))
  
  #only do the following for worms that have 2 ends
  if(length(data_w_angles[data_w_angles$is_end == "YES","is_end"]) == 2){
    #start from one end (because we ordered by is_end above)
    pos_list <- data_w_angles[1, "pos"]
    
    
    # looks for the next position until the next end is found
    #if there is a round structure this can go into a endless loop, therefore don't make the list longer than the total number of pixels with value == 1
    while(tail(pos_list, n=1) != "0,0" && length(pos_list) < length(data_w_angles$value)){
      next_pos <- data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_1"]
      if(next_pos %in% pos_list){
        pos_list <- append(pos_list, data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_2"])
      }else{
        pos_list <- append(pos_list, next_pos)
      }
      if(length(unique(pos_list)) != length(pos_list)){
        pos_list <- NA
        break
      }
    }
    
    data <- data %>%
      mutate(midline_length = length(pos_list))
    
  } else {
    data <- data %>%
      mutate(midline_length = NA)
    
  }
  
}
#########################################


#get file path from command line
dataraw_file_path <- commandArgs(trailingOnly = TRUE)[1]
conversion_factor <- as.numeric(commandArgs(trailingOnly = TRUE)[2])


#create file path for saving
save_path <- file.path(dirname(dataraw_file_path),"size")
#create the save path directories
dir.create(save_path,recursive = TRUE)
#catch toprocess_size.txt location
toprocess_file_path <- file.path(file.path(dataraw_file_path, "toprocess_size.txt"))


#extract list of datasets to process from "toprocess_size.txt" file
list_of_datasets <- as.matrix(read.table(toprocess_file_path))
files_to_process <- paste0(paste0(file.path(dataraw_file_path,list_of_datasets),"_raw_data.rds"))



#list of .rds files in data folder that were already analysed for centroid tracking
names_already_processed <- unique(gsub(".+\\/(.+)\\_centroid.+","\\1",list.files(save_path, "size_converted", full.names = TRUE, ignore.case = TRUE)))
files_already_processed <- paste0(paste0(file.path(dataraw_file_path,names_already_processed),"_raw_data.rds"))

if(length(files_already_processed) > 0){
  #remaining annotations to process
  files_to_process_cleaned <- files_to_process[!files_to_process %in% files_already_processed]
} else {
  files_to_process_cleaned <- files_to_process
}

#print(files_to_process_cleaned)

#
if (length(files_to_process_cleaned) > 0){
  for (file in files_to_process_cleaned){
    
    filename <- gsub("(.+)\\_raw_data.rds", "\\1",basename(file))
    cat(paste0("\nConverting ", filename))
    
    imported_data_temp <- readRDS(file) %>%
      #minimal track displacement to exclude artifacts of aggregating worms happening after ca. 16h
      filter(Track_displacement > 150) %>%
      #only tracks that are longer than 20s
      #same as for calculating motion parameters
      mutate(Duration_of_track_in_s = Duration_of_track/downsampled_to) %>%
      filter(Duration_of_track_in_s > 20) %>%
      #calculate average size, major and minor axis BY TRACK
      group_by(annotation,dataset_ID, tp,minutes,TrackID) %>%
      #guess direction from centroid movement for every Track
      group_modify(~ skeleton_direction(.x)) %>%
      group_by(annotation, dataset_ID, tp,minutes, TrackID,frame) %>%
      #count number of midline pixels for every frame
      group_modify(~ count_midline_pixels(.x)) %>%
      group_by(annotation,dataset_ID, tp,minutes,TrackID) %>%
      summarise(size=median(Size),midline=median(midline_length,na.rm = TRUE)) %>%
      #round to full hour steps
      mutate(hours_rounded = ceiling(minutes/60)) %>%
      filter(hours_rounded <= 20) %>%
      mutate(time= ifelse(hours_rounded <= 5, 5, NA)) %>%
      mutate(time = ifelse(hours_rounded <= 10 & hours_rounded > 5, 10, time)) %>%
      mutate(time = ifelse(hours_rounded <= 15 & hours_rounded > 10, 15, time)) %>%
      mutate(time = ifelse(hours_rounded <= 20 & hours_rounded > 15, 20, time)) %>%
      na.omit() %>%
      #multiply by pixel conversion factor to get values in µm
      # mutate(major = conversion_factor * major, minor = conversion_factor * minor, midline = conversion_factor * midline) %>%
      mutate(midline = conversion_factor * midline) %>%
      #get annotation from file name
      mutate(annotation = gsub("(.+)\\_long.+","\\1", annotation))
    
    save_path <- file.path(target_path,"converted")
    dir.create(save_path)
    
    saveRDS(imported_data_temp, file.path(save_path, paste0(filename, "_size_converted.RDS")))
    cat(paste0("\n",filename, " was converted and saved."))
  }
} else {
  cat("All datasets in ", dataraw_file_path," already processed.")
}

