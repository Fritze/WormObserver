# Here we do k-means clustering on (filtered) skeletons (individually for each annotation/dataset.

# Needed: Filtered .RDS files that contain filtered skeletons as written out by "filter_skeletons.R"
# These files should be named "datasetID_skeletonized_filtered.RDS"

#Also needed: A metadata file that is located in the folder that contains the "raw_data.RDS" files generated by the "data_grouping.R" (i.e. the directory that contains the acquired experiments)
# This file should be named "toprocess_cluster_skeletons.txt" and contain the conditions you want to cluster,

# To run the script type: Rscript cluster_skeletons.R "the location of your raw data folder"
# e.g. Rscript cluster_skeletons.R /media/fpreuss/raid5/timelapses/analysis/paper/data/raw

library("tidyverse")
library("reshape2")

###### functions ######

#this function compares postures and identifies mirrored postures
#performed after group_by(clusterID) so that it is performed individually for each posture
#we calculate mean absolute angle difference per posture and take the one with the closest mean to 0
diff_to_angle <- function(one_posture,other_postures){
  #empty dataframe to save ID and angle difference
  mean_angle_diff_all <- data.frame(compare_to=character(),
                                    sum_angle_diff=numeric(),stringsAsFactors = FALSE)
  #current posture to be compared against
  selected_posture <- select(one_posture,posture) %>% distinct(posture) %>% pull()
  # print(selected_posture)
  #other postures to compare against (i.e. all postures except selected_posture)
  IDs_to_check <- filter(other_postures, clusterID != selected_posture) %>%
    distinct(clusterID) %>%
    pull()
  #current mirrored posture angles
  v_angle_mirror <- filter(one_posture, posture == selected_posture) %>%
    select(angle_mirror) %>%
    pull()
  
  # print(IDs_to_check)
  #this wil be done for every posture to which we compare
  for(i in IDs_to_check){
    mean_angle_diff <- other_postures %>%
      #select a posture to compare
      filter(clusterID == i) %>%
      mutate(compare_to = clusterID) %>%
      select(-clusterID) %>%
      #append mirrored posture angles
      mutate(angle_mirror = v_angle_mirror) %>%
      #do the angle difference calculation for all angles
      mutate(angle_diff = angle_mirror-angle) %>%
      #take the mean of the abs of the difference
      mutate(angle_diff = mean(abs(angle_diff))) %>%
      select(compare_to, angle_diff)
    #poppulate the dataframe so that you have all values from all other postures that we compared with
    mean_angle_diff_all <- rbind(mean_angle_diff_all,mean_angle_diff)
    
  }
  
  #the posture ID of the mean(abs(angle_diff)) that is closest to zero
  closest <- pull(mean_angle_diff_all[which.min(abs(mean_angle_diff_all$angle_diff - 0)),"compare_to"])
  # print(closest)
  #the angle_diff value for the above posture ID
  score <- pull(mean_angle_diff_all[which.min(abs(mean_angle_diff_all$angle_diff - 0)),"angle_diff"])
  # print(score)
  #append this two values to the selected posture
  one_posture <-one_posture %>%
    mutate(mirroredID = closest) %>%
    mutate(difference = score)
  
}


#function to estimate the worm posture based on list of angles
estimate_positions_from_angles <- function(input_data) {
  #for every skeleton (therefore this function has to be preceded by group_by(ID))
  n <- nrow(input_data)
  #we go from the end of the worm to it's head
  for(i in (n-1):1) {
    #add previous angle to current angle
    input_data$new_angle[i] <- input_data$new_angle[i+1] + input_data$angle[i]
    #calculate new position
    input_data$X[i] <- (input_data$X[i+1] + cos(input_data$new_angle[i])) 
    input_data$Y[i] <- (input_data$Y[i+1] + sin(input_data$new_angle[i]))
  }
  #additional part to ensure that x axis is always the major axis
  if(max(input_data$Y) > max(input_data$X)){
    input_data[(ncol(input_data)-1):ncol(input_data)] <- input_data[ncol(input_data):(ncol(input_data)-1)]
  }
  #we end with a dataframe
  input_data <- input_data
}

#this function takes a skeleton and will orient it in a way
#so that: head is on 0 and majority of points is above 0 (i.e. big bulges are pointing upwards)
turn_worm <- function(input_data){
  #looking for the end close to X=0
  only_ends <- input_data[c(1,nrow(input_data)),]
  #Defining X and Y postions for this end
  X_left <- min(only_ends$X)
  Y_left <- pull(only_ends[only_ends$X == X_left,"Y"])
  #Defining X and Y positions for the other end
  X_other <- max(only_ends$X)
  Y_other <- pull(only_ends[only_ends$X == X_other,"Y"])
  
  #diagonal going from left end to right end
  #this defines the new x-axis
  c <- distance(X_left,Y_left,X_other,Y_other)
  a <- Y_other - Y_left
  #calculating the angle by which we have to turn the coordinate system
  angle_t <- asin(a/c)
  
  input_data <- input_data %>%
    mutate(angle_theta = angle_t) %>%
    #turn the coordinate system
    mutate(new_X = X * cos(angle_theta) + Y * sin(angle_theta)) %>%
    mutate(new_Y = Y * cos(angle_theta) - X * sin(angle_theta)) %>%
    #align left end to X = 0
    mutate(new_X = new_X - min(new_X)) %>%
    mutate(new_Y = new_Y - min(new_Y)) %>%
    #diagonal for scaling of X and Y positions
    #we do a shift operation: minimal X and Y positions are new 0
    #and a scale operation: dividing by the diagonal (the "size" of the image)
    mutate(diagonal=sqrt(max(new_X)-min(new_X)*(max(new_X)-min(new_X)) + (max(new_Y)-min(new_Y))*(max(new_Y)-min(new_Y)))) %>%
    mutate(new_X_scaled = (new_X - min(new_X))/diagonal)  %>%
    mutate(new_Y_scaled = (new_Y - min(new_Y))/diagonal) %>%
    select(!c(new_X,new_Y,angle_theta,diagonal))
  
  #if the end close to X=0 is not a head, we want to turn everything by 180° since we want head on X=0
  #check if X_left index is higher than X_other index
  if(pull(only_ends[only_ends$X == X_left,"index"]) > pull(only_ends[only_ends$X == X_other,"index"])){
    # print("turn")
    input_data <- input_data %>%
      #angle 180°
      mutate(angle_t2 = pi) %>%
      mutate(new_X_scaled_temp = new_X_scaled) %>%
      mutate(new_Y_scaled_temp = new_Y_scaled) %>%
      #turn 180°
      mutate(new_X_scaled = new_X_scaled_temp * cos(angle_t2) + new_Y_scaled_temp * sin(angle_t2)) %>%
      mutate(new_Y_scaled = new_Y_scaled_temp * cos(angle_t2) - new_X_scaled_temp * sin(angle_t2)) %>%
      #set min(X) to 0
      mutate(new_X_scaled = new_X_scaled + abs(min(new_X_scaled))) %>%
      select(!c(new_X_scaled_temp,new_Y_scaled_temp,angle_t2))
    input_data <- input_data
  }
  
  #to better compare we want majority of points to be above 0 (e.g. bulges)
  #this is a mirroring operation and won't account for dorsal ventral orientation
  if(mean(input_data$new_Y_scaled) < 0){
    # print("mirror")
    input_data <- input_data %>%
      mutate(new_Y_scaled = -new_Y_scaled)
    input_data <- input_data
  }
  
  input_data$Y <- input_data$new_Y_scaled
  input_data$X <- input_data$new_X_scaled
  input_data <- select(input_data,-c(new_X_scaled,new_Y_scaled))
  input_data <- input_data
}

distance <- function(x1, y1, x2, y2) {
  values <- list(x1, y1, x2, y2)
  if(anyNA(values)) {
    "NA"
  } else {
    length <- sqrt((x1-x2)^2+(y1-y2)^2)
    as.numeric(length)
  }
}
plot_posture_examples <- function(data_to_plot,X,Y){
  ggplot(data_to_plot, aes_string(x=X,y=Y,color="angle"))+
    geom_point(size=1) +
    geom_path(size=3,lineend = "round") +
    theme_void()+
    coord_fixed(ratio = 1)+
    scale_color_gradient2(low = "deepskyblue", mid = "lavender",
                          high = "deeppink",midpoint=0,limits=c(-1,1),na.value="grey") +
    theme(plot.title = element_text(face = "bold"))
  
}



################################################################################


#get file path from command line
dataraw_file_path <- commandArgs(trailingOnly = TRUE)[1]

#create file path for skeletonized data
data_file_path <- file.path(dirname(dataraw_file_path),"skeletonized","filtered")
#create file path for saving
save_path <- file.path(dirname(dataraw_file_path),"skeletonized","clustered")
#create the save path directories
dir.create(save_path,recursive = TRUE)
#catch timelapses_metadata.txt location
toprocess_file_path <- file.path(file.path(dataraw_file_path, "toprocess_cluster_skeletons.txt"))


#extract list of datasets to process from "timelapses_metadata.txt" file
datasets <- as.matrix(read.table(toprocess_file_path))

#list of .rds files in data folder
files_to_process <- list.files(data_file_path, "skeletonized_filtered.rds", full.names = TRUE, ignore.case = TRUE)

#get annotations that have already been processed
datasets_processed <- gsub("(.+)_skeletons_filtered_clustered\\.RDS","\\1",list.files(save_path,pattern="clustered"))

#get datasets that still have to be processed
datasets_to_process <- datasets[!datasets %in% datasets_processed]

#get files that have to be loaded
files_to_process_cleaned <- grep(paste0(".+\\/",paste(datasets_to_process,collapse="|"),"\\_skeletonized.+"),files_to_process,value=TRUE)

for (file in files_to_process_cleaned){
  
  cat(paste0("\n\nloading ",file,"\n\n"))
  skeleton_data_filtered <- file %>%
    map_df(., function(x) readRDS(x)) %>%
    mutate(ID = paste0(dataset_ID, "_",tp,"_",TrackID,"_",frame))
  
  #this is a workaround for attaching the correct offset times (i.e. minutes worms have spent on the plate prior to imaging) to the data
  #we open the grouped raw RDS for this. this is slow.
  #ideally, this should be done in the skeletonization script
  cat(paste0("\n\ncalculating offsets for ",file,"\n\n"))
  
  #function for fetching offsets from grouped raw RDS file
  read_offset <- function(x,y){
    file_path <- file.path(data_path_raw, paste0(x,"_raw_data.rds"))
    temp <- readRDS(file_path) %>%
      filter(dataset_ID %in% y) %>%
      group_by(dataset_ID,time_elapsed,timepoint_length, timestep_length) %>%
      summarise()
    return(temp)
  }
  
  offsets <- read_offset(unique(skeleton_data_filtered$annotation),unique(skeleton_data_filtered$dataset_ID))
  
  #new skeleton data filtered table now with offsets
  skeleton_data_filtered <- skeleton_data_filtered %>%
    left_join(offsets,by="dataset_ID")
  
  #transpose - rows: posture IDs, -columns: angles
  angle_data_cluster <- skeleton_data_filtered %>%
    dcast(ID ~ index,value.var = "angle") %>%
    #make IDs the rowname so that this column is not part of the clustering data
    tibble::column_to_rownames(var = "ID") %>%
    #take out first and last angle
    select(-c(1,ncol(.)))
  


  cat(paste0("\n\ncalculating elbow plot for ",file,"\n\n"))
  
  #here we perform the "elbow plot" for visualizing the explained varience by different numbers of k clusters
  # function to compute total within-cluster sum of square
  wss <- function(k) {
    k <- kmeans(angle_data_cluster, centers=k,nstart = 5,iter.max = 1000,algorithm = "Lloyd")
    perc <- k$betweenss / k$totss
    return(perc)
  }
  
  # Compute and plot wss for k = 1 to k = 200
  k_values <- seq(50,400,50)
  
  # extract wss for  clusters
  wss_values <- data.frame(expvar = map_dbl(k_values, wss)) %>%
    mutate(k=k_values)
  
  #do the plot
  ggplot(data=wss_values,aes(x=k, y=expvar))+
    geom_point()+
    geom_line()+
    geom_vline(x=centers)
    scale_x_continuous(breaks = seq(min(k_values), max(k_values)))+
    theme_classic()
  
  ggsave(file.path(save_path,paste0(paste0(paste0(files_to_process_annotations,collapse = "_"),"_elbow_plot",".png"))),height=49,width=10)  
  
  cat(paste0("\n\nclustering ",file,"\n\n"))
  
  #calculate clusters
  #choose right number of centers!
  centers <- 200
  
  
  cluster <- kmeans(angle_data_cluster,centers=centers,nstart = 5,iter.max = 1000,algorithm = "Lloyd")
  
  
  cluster_centers <- melt(cluster$centers) %>%
    rename("clusterID" = Var1, "index" = Var2, "angle" = value) %>%
    arrange(clusterID) %>%
    #define initial values needed for estimating position from angles
    mutate(new_angle=0, X=1, Y=1) %>%
    group_by(clusterID) %>%
    #estimate the positions for each clusterID independently
    group_modify(~ estimate_positions_from_angles(.x)) %>%
    #turn the coordinates so that the worm's orientations are similar
    group_modify(~ turn_worm(.x)) %>%
    select(-new_angle) %>%
    ungroup()
  
  
  cluster_centers_reduced <- cluster_centers %>%  
    #create mirrored posture
    mutate(angle_mirror = -angle) %>%
    #for every posture (i.e. clusterID)
    group_by(clusterID) %>%
    mutate(posture = clusterID) %>%
    #compare this posture to all others and identify the mirrored version
    group_modify(~ diff_to_angle(.x,cluster_centers)) %>%
    ungroup() %>%
    select(-posture) %>%
    #identify pairs (same difference)
    group_by(difference) %>%
    #the smaller clusterID of the pair will be the newID
    mutate(newID = min(clusterID)) %>%
    group_by(newID,index) %>%
    #newIDs allows to seperate both postures that have been regrouped with common
    mutate(newID_sub = 1:n()) %>%
    mutate(clusterID = as.character(clusterID)) %>%
    arrange(newID) %>%
    ungroup() %>%
    #now replace newID (which corresponds to the smaller old ClusterID) with a new number
    #so that all postures are numbered straight with no gaps
    mutate(newID = as.integer(as.factor(newID))) %>%
    select(-c(angle_mirror,difference))
  
  annotations <- c(unique(skeleton_data_filtered$annotation))
  files_to_process_annotations <- paste(annotations,collapse="_")
  
  
  #this gives out an overview image of all postures (with mirrored corresponding ones)
  plot_posture_examples(cluster_centers_reduced, "X","Y") +
    geom_point(data=filter(cluster_centers_reduced,index == 2), aes(X,Y),color="orange",size=3,shape=17) +
    facet_wrap(vars(newID,newID_sub),ncol=4) +
    theme(strip.text.x = element_text(size = 20,face="bold"))
  ggsave(file.path(save_path,paste0(paste0(paste0(files_to_process_annotations,collapse = "_"),"_posture_angle_centers_mirrorExamples",".png"))),height=49,width=10)
  
  #a dataframe with the clusterID (old as put out by kmeans) and the skeleton ID (from rownames of angle_data_cluster dataframe)
  skeletonIDs_with_postures <- data.frame(clusterID = as.character(cluster$cluster), ID = rownames(angle_data_cluster),stringsAsFactors = FALSE)
  
  
  
  skeleton_data_clustered <- cluster_centers_reduced %>%
    group_by(clusterID,newID) %>%
    summarise() %>%
    arrange(newID) %>%
    #this is only a list of old clusterIDs (as of kmeans) and corresponding new IDs
    select(clusterID,newID) %>%
    #now join this list with the list of all skeleton IDs and their corresponding (old) clusterIDs
    inner_join(skeletonIDs_with_postures,by="clusterID") %>%
    #add skeleton features for every skeleton ID
    left_join(skeleton_data_filtered,by="ID") %>%
    ungroup() %>%
    mutate(minutes = time_elapsed + ((tp-1)*timepoint_length+(tp-1)*timestep_length)) %>%
  
  
  
  cat(paste0("saving ",file,"\n"))
  cluster_centers_reduced_filepath <- file.path(save_path,paste0(paste(files_to_process_annotations,collapse = "_"),"_cluster_centers_reduced.RDS"))
  saveRDS(cluster_centers_reduced, file=cluster_centers_reduced_filepath)
  skeletons_filtered_clustered_filepath <- file.path(save_path,paste0(paste(files_to_process_annotations,collapse = "_"),"_skeletons_filtered_clustered.RDS"))
  saveRDS(skeleton_data_clustered, file=skeletons_filtered_clustered_filepath)
  clustering_filepath <- file.path(save_path,paste0(paste(files_to_process_annotations,collapse = "_"),"_clustering.RDS"))
  saveRDS(cluster, file=clustering_filepath)
  
}
