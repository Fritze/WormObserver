---
title: "WormObserver_analysis_complete"
output: html_document
---
#functions
```{r setup, echo=FALSE}
library("plyr")
library("dplyr")
library("tidyr")
library("ggplot2")
library("rmarkdown")
library("knitr")
library("lubridate")
library("wesanderson")
library("readr")
library("purrr")
library("viridis")
library("png")
library("grid")
library("ggpubr")
library("RColorBrewer")
library("shiny")
library("shinyWidgets")
library("plotly")
library("ggridges")
library("gganimate")
library("cowplot")
library("here")
library("ggbeeswarm")
library("ggsci")
library("reshape2")
library("pracma")
#functions



angle <- function(x1, y1, x2, y2) {
  values <- list(x1, y1, x2, y2)
  if(anyNA(values)) {
    "NA"
  } else {
    x <- c(x1, y1)
    y <- c(x2, y2)
    dot.prod <- x%*%y 
    norm.x <- norm(x,type="2")
    norm.y <- norm(y,type="2")
    theta <- acos(dot.prod / (norm.x * norm.y))
    as.numeric(theta)
  }
}

angle2 <- function(x1, y1, x2, y2) {
  atan2(y2,x2) - atan2(y1,x1) 
}


distance <- function(x1, y1, x2, y2) {
  values <- list(x1, y1, x2, y2)
  if(anyNA(values)) {
    "NA"
  } else {
    length <- sqrt((x1-x2)^2+(y1-y2)^2)
    as.numeric(length)
  }
}

# the function which will change all values of a given column to NA, except those rows that are consecutive for y times
replace_f <- function(x,y){
  subs <- rle(x)
  subs$values[subs$lengths < y] <- NA
  inverse.rle(subs)
}

myPalette <- colorRampPalette(rev(brewer.pal(11, "Spectral")))



data_filtering<- function(data_input,conversion_factor, offset,binning_factor, max_gaps, duration){
    data_input %>%
    mutate(grouping = paste0(dataset_ID, "_", tp, "_", TrackID)) %>%
    filter(Number_of_gaps <= max_gaps) %>%
    filter(Duration_of_track >= duration) %>%
    group_by(grouping) %>%
    mutate(Track_displacement=Track_displacement * conversion_factor) %>%
    mutate(seconds=frame / downsampled_to) %>%
    mutate(x_lag=location_x - lag(location_x,n=offset), y_lag = location_y -lag(location_y, n=offset)) %>%
    mutate(x_lead=lead(location_x, n=offset)-location_x, y_lead=lead(location_y, n=offset)-location_y) %>%
    mutate(location_x_norm = (location_x/1024)) %>%
    mutate(location_y_norm = (location_y/1024)) %>%
    mutate(angle=suppressWarnings(as.numeric(mapply(angle,x_lag,y_lag,x_lead,y_lead)))*180/pi) %>%
    mutate(local_distance=suppressWarnings(as.numeric(mapply(distance,x_lag,y_lag,x_lead,y_lead)))) %>%
    # mutate(local_distance = local_distance * conversion_factor) %>%
    mutate(aspect_ratio=Minor/Major) %>%
    na.omit() %>%
    mutate(mean_local_distance=mean(local_distance)) %>%
    mutate(state= if_else(local_distance < 2.5,"pause","straight")) %>%
    mutate(state= if_else(mean_local_distance < 2.5,"pause",state)) %>%
    mutate(omega_turn_parameter_based = if_else(angle > 120,"turn","no")) %>%
    mutate(state=if_else((omega_turn_parameter_based == "turn" & state != "pause"), "turn",state)) %>%
    mutate(binning=rep(0:n(),each=binning_factor,length.out=n())) %>%
    ungroup() %>%
    group_by(grouping,binning) %>%
    mutate(state_binned = names(table(state))[which.max(table(state))]) %>%
    mutate(state_binned=if_else((state == "turn" & Circularity > 0.4), "omega_turn",state)) %>%
    ungroup()
}
params_statistics <- function(input_data,how_to){
  if (how_to == "mutate"){
  input_data %>%
  na.omit() %>%
  #this will be computed on a "per track basis"
  mutate(p_mean_angle = mean(angle),
         p_sd_local_angle = sd(angle),
         p_displacement = first(Track_displacement*conversion_factor),
         p_displacement_distance_ratio = mean(Track_displacement) / sum(local_distance),
         p_mean_velocity = mean(Mean_velocity*conversion_factor/downsampled_to),
         p_track_length_secs = mean(Duration_of_track/downsampled_to),
         p_sum_turns = sum(omega_turn_parameter_based == "turn"),
         p_sum_turns_ml = sum(Prediction == "turn"),
         p_turns_per_s = p_sum_turns / p_track_length_secs,
         p_turns_ml_per_s = p_sum_turns_ml / p_track_length_secs,
         p_eccentricity = mean(Eccentricity),
         p_size = mean(Size),
         p_length=mean(Major*conversion_factor),
         p_major_minor_ratio = mean(Major)/mean(Minor))
  } else if (how_to == "summarise"){
  input_data %>%
  na.omit() %>%
  summarise(p_mean_angle = mean(angle),
         p_sd_local_angle=sd(angle),
         p_displacement=first(Track_displacement*conversion_factor),
         p_displacement_distance_ratio= mean(Track_displacement) / sum(local_distance),
         p_mean_velocity=mean(Mean_velocity*conversion_factor/downsampled_to),
         p_track_length_secs = mean(Duration_of_track/downsampled_to),
         p_sum_turns = sum(omega_turn_parameter_based == "turn"),
         p_sum_turns_ml = sum(Prediction == "turn"),
         p_turns_per_s = p_sum_turns / p_track_length_secs,
         p_turns_ml_per_s = p_sum_turns_ml / p_track_length_secs,
         p_eccentricity = mean(Eccentricity),
         p_size = mean(Size),
         p_length=mean(Major*conversion_factor),
         p_major_minor_ratio = mean(Major)/mean(Minor),
         perc_turn = sum(state_binned == "turn")/n(),
         perc_omega_turn = sum(state_binned == "omega_turn")/n(),
         perc_straight = sum(state_binned == "straight")/n(),
         perc_pause = sum(state_binned == "pause")/n())
  }
}

minutes_to_corresponding_tp <- function(input_data,time_input_type,time_input){
  if(time_input_type == "minutes"){
    all_tps_in_minutes <- unique(input_data$minutes)
    corresponding_minute <- all_tps_in_minutes[which(abs(all_tps_in_minutes-time_input)==min(abs(all_tps_in_minutes-time_input)))]
    selected_tp <<- unique(input_data[input_data$minutes == corresponding_minute,"tp"])
  }else{
    selected_tp <<- time_input
  }
}

plot_paths <- function(selected_tp,selected_frame,which_dataset,color_path,image){  
  p <- ggplot(data_for_plotting)+
    theme(aspect.ratio = 1024/1024)+
    coord_cartesian(ylim=c(0, 1023))+
    scale_x_continuous(expand = c(0, 0), limits= c(0,1023)) + scale_y_continuous(expand = c(0, 0),trans="reverse")+
    ggtitle(paste0("tp_",selected_tp))
  
  if(image == "with_image"){
    tp <- paste0("tp_",selected_tp)
    frame_png <- paste0(sprintf("%03d", selected_frame),".png")
    location_dataset <- target_folder_general[grep(which_dataset, target_folder_general)]
    img <- readPNG(file.path(target_folder_base,location_dataset,tp,frame_png))
    p <- p + background_image(img) + theme_black() + theme(axis.title=element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.background = element_rect(fill = "black"),legend.direction="vertical")
  }else{
    p <- p  + theme_black() + theme(legend.direction="vertical") + theme(axis.title=element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.background = element_rect(fill = "black"))
  }
  if(color_path == "mean_angle"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 180))
    p <- p +
      sc + 
      geom_path(aes(x=location_x, y=location_y,col=p_mean_angle, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "ID"){
    p <- p +
      geom_path(aes(x=location_x, y=location_y,col=TrackID, group=grouping,size=path_size), alpha=0.75)+
      theme(
        legend.position = "none")
  }else if(color_path == "frame"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 960))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=frame, group=grouping,sizepath_size), alpha=0.75)
  }else if(color_path == "displacement"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 6300))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=p_displacement, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "velocity"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 50))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=p_mean_velocity, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "length"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 480))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=p_track_length_secs, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "displacement_distance_ratio"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 1))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=p_displacement_distance_ratio, group=grouping,size=0.6), alpha=0.5)
  }else if(color_path == "sd_local_angle"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 75))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=p_sd_local_angle, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "eccentricity"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, max(0.9)))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=p_eccentricity, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "local_velocity"){
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 150))
    p <- p +
      sc +
      geom_path(aes(x=location_x, y=location_y,col=local_distance, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "turns"){
    p <- p +
      scale_colour_hue() +
      geom_path(aes(x=location_x, y=location_y,col= omega_turn_parameter_based, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "turns_ml"){
    p <- p +
      scale_colour_hue() +
      geom_path(aes(x=location_x, y=location_y,col=Prediction, group=grouping,size=path_size), alpha=0.75)
  }else if(color_path == "path_class_binned"){
    p <- p +
      scale_colour_brewer(palette="Set1")+
      geom_path(aes(x=location_x, y=location_y,col=state_binned, group=grouping),size=1, alpha=0.4)
  }else{
    sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 180))
    p <- p +
      sc+
      geom_path(aes(x=location_x, y=location_y,col=angle, group=grouping,size=path_size), alpha=0.75)
  }
}


plot_image_with_path <- function(which_tracks,which_track,offset,binning_factor,conversion_factor,time_input_type,time_input,which_dataset,max_number_gaps,duration,selected_frame,color_path,image) {
  sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 180))
  data_sub_dataset <- data %>%
    filter(dataset_ID == which_dataset)
  minutes_to_corresponding_tp(data_sub_dataset,time_input_type,time_input)
  if(which_tracks == "current_frame"){
    data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp) %>%
    group_by(TrackID) %>%
    filter(any(frame == selected_frame))
  }else if(which_tracks == "until_this_frame"){
    data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp) %>%
    filter(frame <= selected_frame)
  }else if(which_tracks == "until_and_current"){
    data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp) %>%
    group_by(TrackID) %>%
    filter(any(frame == selected_frame+10)) %>%
    ungroup() %>%
    filter(frame <= selected_frame+10)
  }else{
    data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp)
  }
  data_for_plotting <<- data_filtering(data_sub_dataset_tp,conversion_factor, offset,binning_factor, max_number_gaps,duration) %>%
    group_by(TrackID) %>%
    params_statistics(., "mutate") %>%
    mutate(path_size=if_else(TrackID == which_track, "selected", "not_selected"))
  
  print(plot_paths(selected_tp,selected_frame,which_dataset,color_path,image)+scale_size_discrete(range = c(1, 2)))
}


save_plot_image_with_path <- function(which_tracks,which_track,offset,binning_factor,conversion_factor,time_input_type,time_input,which_dataset,max_number_gaps,duration,selected_frame,color_path,image) {
  for(i in seq(1, selected_frame)){
    selected_frame <- i
    path <- here("Image_analysis/R/plots", which_dataset,time_input,color_path)
    dir.create(path,recursive = TRUE,showWarnings=FALSE)
    #png(file=file.path(path,paste0("tp_",selected_tp,"_",round(selected_frame,3),".png")))
    plot_image_with_path(which_tracks,which_track,offset,binning_factor,conversion_factor,time_input_type,time_input,which_dataset,max_number_gaps,duration,selected_frame,color_path,image)+
      ggsave(file=file.path(path,paste0("tp_",selected_tp,"_",sprintf("%03d",selected_frame),".png")),height = 200, width = 200,units="mm")

    #dev.off()
  }
}

plot_image_with_path_centered <- function(which_tracks,offset,binning_factor,conversion_factor,time_input_type,time_input,which_dataset,max_gaps,duration,selected_frame,color_path,image) {
  sc <- scale_colour_gradientn(colours = myPalette(100), limits=c(0, 180))
  data_sub_dataset <- data %>% filter(dataset_ID == which_dataset)
  minutes_to_corresponding_tp(data_sub_dataset, time_input_type, time_input)
  if(which_tracks == "all_frames"){
    data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp)
  }else{
    data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp) %>%
    filter(frame == selected_frame)
  }

  
  data_for_plotting <<- data_filtering(data_sub_dataset_tp, conversion_factor, offset, binning_factor, max_gaps, duration) %>%
    group_by(TrackID) %>%
    na.omit() %>%
    params_statistics(., "mutate") %>%
    mutate(first_x = first(location_x),first_y = first(location_y)) %>%
    mutate(location_x = location_x - first_x, location_y=location_y - first_y)
  
  pc <<- plot_paths(selected_tp,selected_frame,which_dataset,color_path,image)+
    coord_cartesian(ylim=NULL,xlim=NULL)+
    scale_x_continuous(limits= c(-1024,1024)) +
    scale_y_continuous(limits= c(-1024,1024))
  print(pc)

}

plot_single_path_states <-  function(which_track,conversion_factor,binning_factor,offset,time_input_type,time_input,selected_frame,which_dataset,max_gaps,duration,color_path,image){
  data_sub_dataset <- data %>% filter(dataset_ID == which_dataset)
  minutes_to_corresponding_tp(data_sub_dataset, time_input_type, time_input)
  data_sub_dataset_tp <- data_sub_dataset %>%
    filter(tp == selected_tp)
  data_for_plotting <<- data_filtering(data_sub_dataset_tp, conversion_factor, offset, binning_factor,max_gaps, duration) %>%
    filter(TrackID == which_track) %>%
    na.omit() %>%
    mutate(first_x = first(location_x),first_y = first(location_y)) %>%
    mutate(location_x = location_x - first_x, location_y=location_y - first_y) %>%
    mutate(location_x = location_x * conversion_factor, location_y=location_y * conversion_factor)%>%
    mutate(path_size=0.1)
  #fix colors
  myColors <-  brewer.pal(4,"Set1")
  names(myColors) <- c("pause","straight","turn","omega_turn")
  colScale <- scale_colour_manual(name = "state_binned",values = myColors)
  p1 <- ggplot(data_for_plotting,aes(x=seconds,y=angle,xend=lead(seconds),yend=lead(angle),color=state_binned)) +
    geom_segment()+
    colScale+
    scale_y_continuous(limits=c(0,180))+
    theme_black()+
    theme(legend.position = "top",
          legend.title = element_blank(),
          legend.text = element_text(size=12),
          axis.title.x=element_blank(),
          axis.text.x=element_blank())
    # geom_vline(xintercept=selected_frame/2, linetype="dashed", color = "white")
   
  p2 <- ggplot(data_for_plotting,aes(x=seconds, y=local_distance,xend=lead(seconds),yend=lead(local_distance),color=state_binned))+
    geom_segment()+
    colScale+
    scale_y_continuous(limits=c(0,200))+
    theme_black()+
    theme(legend.position = "none",
          axis.text.x=element_blank(),
          axis.title.x=element_blank())
  p3 <- ggplot(data_for_plotting,aes(x=seconds, y=Circularity,xend=lead(seconds),yend=lead(Circularity),color=state_binned))+
    geom_segment()+
    colScale+
    scale_y_continuous(limits=c(0,0.8))+
    theme_black()+
    theme(legend.position = "none")
  pz <- plot_paths(selected_tp,selected_frame,which_dataset,color_path,image)+
    colScale+
    theme(legend.position = "none",
          axis.text=element_text(size=0.05),
          axis.ticks=element_line(color="white",size=0.5),
          axis.title=element_text(size=0.2))+
    coord_cartesian(ylim=NULL,xlim=NULL)+
    scale_x_continuous(limits= c(min(data_for_plotting$location_x),max(data_for_plotting$location_x))) +
    scale_y_continuous(limits= c(min(data_for_plotting$location_y),max(data_for_plotting$location_y))) +
    labs(x = "x (microns)", y= "y (microns)")
  
  left_column <- plot_grid(p1,p2,p3,align = 'hv',axis='l',nrow = 3,rel_heights = c(1,1,1))
  plot_grid(left_column, pz,rel_heights=c(1,20),ncol=2)

  
  }



calculate_overview_statistics <- function(conversion_factor,offset,binning_factor,max_gaps,duration) {
  dfp <<- data_filtering(data, conversion_factor, offset, binning_factor, max_gaps,duration) %>%
    group_by(TrackID, tp, minutes, hours,dataset_ID,file_name,worm_type,plate_type,Duration_of_track) %>%
    na.omit() %>%
    params_statistics(., "summarise")
    
  
}

theme_black = function(base_size = 12, base_family = "") {
  
  theme_classic(base_size = base_size, base_family = base_family) %+replace%
    
    theme(
      # Specify axis options
      axis.line = element_line(colour = "white"),  
      axis.text.x = element_text(size = base_size, color = "white", lineheight = 0.9),  
      axis.text.y = element_text(size = base_size, color = "white", lineheight = 0.9),  
      axis.ticks = element_line(color = "white", size  =  0.2),  
      axis.title.x = element_text(size = base_size, color = "white", margin = margin(0, 10, 0, 0)),  
      axis.title.y = element_text(size = base_size, color = "white", angle = 90, margin = margin(0, 10, 0, 0)),  
      axis.ticks.length = unit(0.3, "lines"),   
      # Specify legend options
      legend.background = element_rect(color = NA, fill = "black"),  
      legend.key = element_rect(color = NA,  fill = "black"),  
      legend.key.size = unit(1.2, "lines"),  
      legend.key.height = NULL,  
      legend.key.width = NULL,      
      legend.text = element_text(size = base_size*0.8, color = "white"),  
      legend.title = element_text(size = base_size*0.8, face = "bold", hjust = 0, color = "white"),  
      legend.position = "right",  
      legend.text.align = NULL,  
      legend.title.align = NULL,  
      legend.direction = "horizontal",  
      legend.box = NULL, 
      # Specify panel options
      panel.background = element_rect(fill = "black", color  =  NA),  
      panel.border = element_blank(),  
      panel.grid.major = element_blank(),  
      panel.grid.minor = element_blank(),  
      panel.spacing = unit(0.5, "lines"),   
      # Specify facetting options
      strip.background = element_blank(), #(fill = "grey30", color = "grey10"),  
      strip.text.x = element_text(size = base_size*0.8, color = "white", face = "italic"),  
      strip.text.y = element_text(size = base_size*0.8, color = "white",angle = -90),  
      # Specify plot options
      plot.background = element_rect(color = "black", fill = "black"),  
      plot.title = element_text(size = base_size*1.2, color = "white"),  
      plot.margin = unit(rep(1, 4), "lines")
      
    )
  
}
```




#define data paths
```{r, include=FALSE}
target_folder_base <- ("/Users/fpreuss/Desktop/tracking_demo/")
target_folder_general <- c("2019-03-26_19-27-16")
                           # "2019-03-07_17-28-51",
                           # "2019-03-11_17-54-09",
                           # "2019-03-18_18-01-40",
                           # "2019-03-19_17-40-32",
                           # "2019-03-25_18-10-06",#no food
                           # "2019-03-27_18-24-47"
                           # "2019-03-26_19-27-16",
                           # "2019-04-15_17-32-23",
                           # "2019-04-23_17-46-08",#daf2
                           # "2019-04-30_14-15-44",#L2
                           # "2019-05-04_15-36-42",#L2
                           # "2019-05-07_12-15-40",#daf2
                           # "2019-05-08_14-11-15"#daf2
                           # )

target_folder_analysis <- file.path(target_folder_base,target_folder_general, "analysis")


```

#load metadata (for all datasets)
```{r, include=FALSE}
metadata_file <- list.files(file.path(target_folder_base,target_folder_general),pattern=".+\\_metadata.txt$", full.names = TRUE)
metadata <- data.frame(sapply(metadata_file, function (x) read.delim(x,header=FALSE,check.names = FALSE)))
colnames(metadata) <- metadata_file
colnames(metadata) <- as.character(gsub(".+\\/", "",colnames(metadata)))
colnames(metadata) <- as.character(gsub("_metadata.txt", "",colnames(metadata)))


time_elapsed <- apply(metadata,2, function(x) as.numeric(gsub(".+\\s([0-9]+).*", "\\1",x[grepl("Time elapsed.+\\:\\s(.+)",x)])))
time_elapsed <- as.data.frame(time_elapsed)
time_elapsed$dataset <- gsub(".+\\/([0-9]+\\-[0-9]+\\-[0-9]+\\_[0-9]+\\-[0-9]+\\-[0-9]+)\\/.+", "\\1",rownames(time_elapsed))


#timepoint length, in minutes
#attention to divide everything by 60, because this value is entered in seconds
timepoint_length <- apply(metadata,2, function(x) as.numeric(gsub(".+\\:\\s(.+)", "\\1",x[grepl("Timepoint length\\:\\s(.+)\\.",x)])))/60
timepoint_length <- as.data.frame(timepoint_length)
timepoint_length$dataset <- gsub(".+\\/([0-9]+\\-[0-9]+\\-[0-9]+\\_[0-9]+\\-[0-9]+\\-[0-9]+)\\/.+", "\\1",rownames(timepoint_length))


#timestep, in minutes
timestep_length <- apply(metadata,2, function(x) as.numeric(gsub(".+every(.+)minutes\\.", "\\1",x[grepl(".+every(.+)minutes\\.",x)])))
timestep_length <- as.data.frame(timestep_length)
timestep_length$dataset <- gsub(".+\\/([0-9]+\\-[0-9]+\\-[0-9]+\\_[0-9]+\\-[0-9]+\\-[0-9]+)\\/.+", "\\1",rownames(timestep_length))

#plate type
plate_type <- apply(metadata,2, function(x) gsub(".+\\,(.+)\\,.+", "\\1",x[grepl("Timelapse plate type\\:",x)]))
plate_type <- as.data.frame(plate_type)
plate_type$dataset <- gsub(".+\\/([0-9]+\\-[0-9]+\\-[0-9]+\\_[0-9]+\\-[0-9]+\\-[0-9]+)\\/.+", "\\1",rownames(plate_type))

#worm type
worm_type <- apply(metadata,2, function(x) gsub(".+\\:\\s(.+)", "\\1",x[grepl("Used line\\:",x)]))
worm_type <- as.data.frame(worm_type)
worm_type$dataset <- gsub(".+\\/([0-9]+\\-[0-9]+\\-[0-9]+\\_[0-9]+\\-[0-9]+\\-[0-9]+)\\/.+", "\\1",rownames(worm_type))

```


#import timelapse data
```{r, include=FALSE}
#list zip files in target_folder_analysis
zip_files <- list.files(target_folder_analysis,pattern=".zip")

import_data <- function(zip_files){
  ds_all_tps <- NULL
  for(z in zip_files){
      print(z)
      ds <- read_csv(file.path(target_folder_analysis,z), col_types=cols(),col_names=TRUE)
      #append column with file name
      ds$file_name <- file.path(target_folder_analysis,z)
      #extract the timelapse name from the folder structure
      ds$dataset_ID <- gsub(".+\\/([0-9]+\\-[0-9]+\\-[0-9]+\\_[0-9]+\\-[0-9]+\\-[0-9]+)\\/.+", "\\1",ds$file_name)
      ds_all_tps <- rbind(ds_all_tps,ds)
      return(ds_all_tps)
  }
}

#apply the import function defined above to all csv files (from all timelapses)
data <- ldply(.data=zip_files,.fun=import_data) %>%
  #replace all whitespaces in column names with "_"
  rename_all(list(~gsub("\\s", "_",.))) %>%
  inner_join(., time_elapsed,by = c("dataset_ID" = "dataset")) %>%
  inner_join(., timepoint_length,by = c("dataset_ID" = "dataset")) %>%
  inner_join(., timestep_length,by = c("dataset_ID" = "dataset")) %>%
  inner_join(., plate_type, by = c("dataset_ID" = "dataset")) %>%
  inner_join(., worm_type, by = c("dataset_ID" = "dataset")) %>%
  mutate(timestep_length = ifelse(timepoint_length > timestep_length, 0,timestep_length-timepoint_length)) %>%
  mutate(minutes = time_elapsed + ((tp-1)*timepoint_length+(tp-1)*timestep_length)) %>%
  mutate(hours= minutes/60) %>%
  na.omit()

#downsampled to for conversion
downsampled_fps <- unique(na.omit(data$downsampled_to))

```



```{r, include=FALSE}

#the function that orders pixels and finds the head
skeleton <- function(datasetIDs, TrackIDs, selected_timepoints,frames){
  skeleton_data_all <<- data.frame() #set global variable to 0
  #for every dataset ...
  for(timelapse in datasetIDs){
    dataset_selected <- data %>%
      filter(dataset_ID == timelapse)
    for (timepoint in selected_timepoints){
      #for every timepoint ...
      ds_tp <- dataset_selected %>%
        filter(tp == timepoint)
      #for every track ...
      for(t in TrackIDs){
        cat("\n")
        print(t)
        if(t %in% unique(ds_tp$TrackID)){
          ds_tp_track <- ds_tp %>%
            filter(TrackID == t) %>%
            #compute the location of the centroid of the worm after one second
            #this gives us an idea about the direction
            mutate(x_lead=lead(location_x, n=2)-location_x, y_lead=lead(location_y, n=2)-location_y) %>%
            mutate(x_lag=lag(location_x, n=2)-location_x, y_lag=lag(location_y, n=2)-location_y) %>%
            # mutate(local_distance=suppressWarnings(as.numeric(mapply(distance,x_lag,y_lag,x_lead,y_lead))))
            mutate(x_dir = ifelse(x_lead < 0, "left","right")) %>%
            mutate(y_dir = ifelse(y_lead < 0, "up","down")) %>%
            mutate(direction = paste(x_dir,y_dir,sep="-"))
          #only keep the direction when direction is stable over 5 seconds 
          ds_tp_track$direction <- replace_f(ds_tp_track$direction,10)
        
          #for every frame
          for(f in frames){
          # foreach (f=frames) %dopar% {
            #only if this track contains the given frame number
            if (f %in% ds_tp_track$frame) {
              #get dimension from table, variables bitmask_dim_Y and bitmask_dim_X
              dim_Y <- as.numeric(filter(ds_tp_track,frame == f) %>% select(bitmask_dim_Y))
              dim_X <- as.numeric(filter(ds_tp_track,frame == f) %>% select(bitmask_dim_X))
              #import the data from bitmask column and transform to matrix with right dimensions
              bitmask <- filter(ds_tp_track,frame == f) %>% select(bitmask)
              bitmask <- strsplit(as.character(unlist(bitmask)),",")
              bitmask <- as.numeric(unlist(lapply(bitmask,gsub,pattern=".*(\\d+)\\..+", replacement="\\1")))
              data_imported <- matrix(bitmask,nrow=dim_Y, byrow=TRUE)
              
              #add 2 columns and 2 frames (as a "frame" around the bitmask)
              data_imported <- rbind(data_imported, rep(0,ncol(data_imported)))
              data_imported <- rbind(rep(0,ncol(data_imported)),data_imported)
              data_imported <- cbind(rep(0, nrow(data_imported)),data_imported)
              data_imported <- cbind(data_imported,rep(0, nrow(data_imported)))
              
              #if dimension X is bigger than Y (== landscape), make it portrait
              # if(dim_X > dim_Y){
              #   #swap dimension
              #   #add two to get the new dimensions right
              #   dim_Y <- as.numeric(filter(ds_tp_track,frame == f) %>% select(bitmask_dim_X))+2
              #   dim_X <- as.numeric(filter(ds_tp_track,frame == f) %>% select(bitmask_dim_Y))+2
              #   #here is where the transformation around 90° happens
              #   data_imported <- t(data_imported) %>%
              #     melt(.) %>%
              #     rename(Y = 1, X = 2,value = 3) %>%
              #     mutate(next_px_1_x = 0, next_px_1_y = 0,
              #            next_px_2_x = 0, next_px_2_y = 0)
              #   
              # } else {
                #add two to get the new dimensions right
                dim_X <- as.numeric(filter(ds_tp_track,frame == f) %>% select(bitmask_dim_X))+2
                dim_Y <- as.numeric(filter(ds_tp_track,frame == f) %>% select(bitmask_dim_Y))+2
                #here we don't transform
                data_imported <- data_imported %>%
                  melt(.) %>%
                  rename(Y = 1, X = 2,value = 3) %>%
                  mutate(next_px_1_x = 0, next_px_1_y = 0,
                          next_px_2_x = 0, next_px_2_y = 0)
              # }
              
            
              #this is a ggplot to check if the skeleton was imported right
              # ggplot(data_imported %>% filter(value==1), aes(x=X,y=Y))+
              #     coord_equal() +
              #     geom_raster(aes(fill="black"))+
              #     scale_x_continuous(expand = c(0, 0), limits= c(0,dim_X)) +
              #     scale_y_continuous(expand = c(0, 0),trans="reverse") +
              #     # theme_void()+
              #     theme(legend.position="none")

              #create an empty list
              #here for each pixel we will find the surounding pixels (max. 8) that are having value "1"
              pixel_list <- vector(mode="list",length=0)
              for(i in seq(1,nrow(data_imported)-dim_Y)){
                if(data_imported[i,"value"] == 1){
                  if(data_imported[i+1,"value"] == 1){#0°
                    pixel_list <- append(pixel_list,paste(data_imported[i+1,"X"],data_imported[i+1,"Y"], sep=","))}
                  if(data_imported[i+dim_Y+1,"value"] == 1){#45°
                    pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y+1,"X"],data_imported[i+dim_Y+1,"Y"], sep=","))}
                  if(data_imported[i+dim_Y,"value"] == 1){#90°
                    pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y,"X"],data_imported[i+dim_Y,"Y"], sep=","))}
                  if(data_imported[i+dim_Y-1,"value"] == 1){#135°
                    pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y-1,"X"],data_imported[i+dim_Y-1,"Y"], sep=","))}
                  if(data_imported[i-1,"value"] == 1){#180°
                    pixel_list <- append(pixel_list,paste(data_imported[i-1,"X"],data_imported[i-1,"Y"], sep=","))}
                  if(data_imported[i-dim_Y-1,"value"] == 1){#225°
                    pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y-1,"X"],data_imported[i-dim_Y-1,"Y"], sep=","))}
                  if(data_imported[i-dim_Y,"value"] == 1){#270°
                    pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y,"X"],data_imported[i-dim_Y,"Y"], sep=","))}
                  if(data_imported[i-dim_Y+1,"value"] == 1){#315°
                    pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y+1,"X"],data_imported[i-dim_Y+1,"Y"], sep=","))}
                }
                #if only one neighbouring pixel is found then it most likely corresponds to the end (head or tail of the worm)
                if(length(pixel_list) == 1 ){
                  data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
                    data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
                    data_imported[i,"is_end"] <- "YES"
                    pixel_list <- vector(mode="list",length=0)
                #if there are more than one neighbouring pixels than the pixel in question sits somewhere in the middle
                #so far we only account for more than new two neighbours ...
                } else if(length(pixel_list) > 1){
                  data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
                  data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
                  data_imported[i,"next_px_2_x"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[1])
                  data_imported[i,"next_px_2_y"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[2])
                  data_imported[i,"is_end"] <- "NO"
                  pixel_list <- vector(mode="list",length=0)
                }
              }
              
              #if there is no pixel found with any neighbours set all pixels to is_end == "NO"
              if (is.null(data_imported$is_end)){
                data_imported$is_end <- "NO"
              }
              
              data_w_angles <<- data_imported %>%
                #only pixels that have value 1 (== no background)
                filter(value == 1) %>%
                #make sure that one endpoint is at the top of the table
                arrange(desc(is_end)) %>%
                #group positions (actual and neighbouring ones to one string)
                mutate(pos = paste(X,Y,sep=",")) %>%
                mutate(next_pos_1 = paste(next_px_1_x,next_px_1_y,sep=",")) %>%
                mutate(next_pos_2 = paste(next_px_2_x,next_px_2_y,sep=",")) %>%
                select(-c(next_px_1_x,next_px_1_y,next_px_2_x,next_px_2_y))
              
              #only do the following for worms that have 2 ends
              if(length(data_w_angles[data_w_angles$is_end == "YES","is_end"]) == 2){
      
                # start from one end (because we ordered by is_end above)
                pos_list <- data_w_angles[1, "pos"]
                
                
                # looks for the next position until the next end is found
                # if there is a round structure this can go into a endless loop, therefore don't make the list longer than the total number of pixels with value == 1
                while(tail(pos_list, n=1) != "0,0" && length(pos_list) < length(data_w_angles$value)){
                  next_pos <- data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_1"]
                  if(next_pos %in% pos_list){
                    pos_list <- append(pos_list, data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_2"])
                  }else{
                    pos_list <- append(pos_list, next_pos)
                  }
                  if(length(unique(pos_list)) != length(pos_list)){
                    pos_list <- NA
                    break
                  }
                }
                
                
                
                #only save those if there are more than 24 pixels and smaller than 60
                if(length(pos_list) > 24 & length(pos_list) < 80){
                  
                  #order pixels in the right order 
                  data_ordered <- data_w_angles[match(pos_list, data_w_angles$pos),] %>%
                    na.omit
  
                  #downsample to 24
                  knots_Y <- linspace(data_ordered$Y[1],data_ordered$Y[nrow(data_ordered)],nrow(data_ordered))
                  knots_X <- linspace(data_ordered$X[1],data_ordered$X[nrow(data_ordered)],nrow(data_ordered))
                  tryCatch({
                    cfit <<- curvefit(knots_X, data_ordered$X, data_ordered$Y,8)
                    px <- c(cfit$px)
                    py <- c(cfit$py)
                    downsampled_knots <<- linspace(data_ordered$X[1],data_ordered$X[nrow(data_ordered)],24)
                  },
                  error = function(e){
                      cfit <<- "no X fit"
                  }
                  )
                  
                  if (!is.list(cfit)){
                    tryCatch({
                      cfit <<- curvefit(knots_Y, data_ordered$X, data_ordered$Y,8)
                      px <- c(cfit$px)
                      py <- c(cfit$py)
                      downsampled_knots <<- linspace(data_ordered$Y[1],data_ordered$Y[nrow(data_ordered)],24)
                      
                    },
                    error  = function(e2){
                      cfit <<- "no X and Y fit"  
                    }
                    )
                  }
                      
                  if (!is.list(cfit)){
                    print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","error when fitting polynomial."))
                    data_dummy <<- data_w_angles %>%
                      filter(NA) %>%
                      add_row() %>%
                      select(-c(pos,value,next_pos_1,next_pos_2)) %>%
                      mutate(index=NA, angle_1 = NA, dim_X = dim_X, dim_Y = dim_Y, prev_px_x = NA, prev_px_y = NA,next_px_x = NA, next_px_y = NA, diff_next_px_x = NA, diff_next_px_y = NA, diff_prev_px_x = NA, diff_prev_px_y = NA, is_head = NA, is_tail = NA, dataset_ID = timelapse, tp = timepoint, frame = f, TrackID = t,TrackCheck = NA)
        
                    skeleton_data_all <<- rbind(skeleton_data_all,data_dummy)
                    
                  } else {
                    
                    xs <- polyval(px, downsampled_knots)
                    ys <- polyval(py, downsampled_knots)
                      
                    #get first and last position to is_end == "YES" (order should be the same as before so we can assume end of dataframe=end of worm)
                    data_ordered_downsampled <- data.frame(cbind(xs,ys))
                    data_ordered_downsampled$is_end <- NA
                    data_ordered_downsampled$is_end[1] <- "YES"
                    data_ordered_downsampled$is_end[24] <- "YES"
                      
                    #add index number for each pixel
                    data_ordered_for_plotting <- data_ordered_downsampled %>%
                      rename("X" = 1, "Y" = 2) %>%
                      mutate(index = row_number()) %>%
                      mutate(next_px_x = lead(X,n=1), next_px_y = lead(Y,n=1)) %>%
                      mutate(prev_px_x = lag(X,n=1),prev_px_y = lag(Y,n=1)) %>%
                      mutate(diff_prev_px_x =  X - prev_px_x, diff_prev_px_y = Y - prev_px_y) %>%
                      mutate(diff_next_px_x = next_px_x - X, diff_next_px_y = next_px_y - Y) %>%
                      mutate(angle_1=suppressWarnings(as.numeric(mapply(angle2,diff_prev_px_x,diff_prev_px_y,diff_next_px_x,diff_next_px_y))))%>%
                      mutate(dataset_ID = timelapse) %>%
                      mutate(tp = timepoint) %>%
                      mutate(frame = f, dim_X = dim_X, dim_Y = dim_Y) %>%
                      mutate(TrackID = t) %>%
                      mutate(is_head = NA) %>%
                      mutate(is_tail = NA) %>%
                      mutate(TrackCheck = t)
                      
                    
                    
                      
                      #if for that frame we have an idea about the direction in which the worm moves (see above), we will try finding a head structure based on this
                      if(!is.na(ds_tp_track[ds_tp_track$frame == f,"direction"])){
                        
                        #for this frame get moving direction
                        x_dir <- ds_tp_track[ds_tp_track$frame == f,"x_dir"]
                        y_dir <- ds_tp_track[ds_tp_track$frame == f,"y_dir"]
                        # get only pixels that describe the end of the worm
                        worm_ends <- filter(data_ordered_for_plotting, is_end == "YES")
                          #here depending on the direction in which the worm moves in the field of view (for X= right or left, for Y=up or down) we translate this information to the bitmask and identify the pixel that is closest to this side 
                          if (x_dir == "right" && y_dir == "up"){
                            data_ordered_for_plotting <- data_ordered_for_plotting %>%
                              mutate(is_head = NA) %>%
                              mutate(is_head = ifelse(X == max(worm_ends$X) & Y == min(worm_ends$Y)  & is_end == "YES","YES", NA)) 
                          } else if (x_dir == "left" && y_dir == "up"){ 
                            data_ordered_for_plotting <- data_ordered_for_plotting %>%
                              mutate(is_head = NA) %>%
                              mutate(is_head = ifelse(X == min(worm_ends$X) & Y == min(worm_ends$Y)  & is_end == "YES","YES", NA)) 
                          } else if (x_dir == "right" && y_dir == "down"){ 
                            data_ordered_for_plotting <- data_ordered_for_plotting %>%
                              mutate(is_head = NA) %>%
                              mutate(is_head = ifelse(X == max(worm_ends$X) & Y == max(worm_ends$Y)  & is_end == "YES","YES", NA)) 
                          } else if (x_dir == "left" && y_dir == "down"){ 
                            data_ordered_for_plotting <- data_ordered_for_plotting %>%
                              mutate(is_head = NA) %>%
                              mutate(is_head = ifelse(X == min(worm_ends$X) & Y == max(worm_ends$Y)  & is_end == "YES","YES", NA))
                          }
                        
                        if(!is.na(data_ordered_for_plotting[nrow(data_ordered_for_plotting),"is_head"])){
                          data_ordered_for_plotting$index <- nrow(data_ordered_for_plotting):1
                        }
                        
                        print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","head found"))
                        #add data for this frame to global list
                        skeleton_data_all <<- rbind(skeleton_data_all, data_ordered_for_plotting)
                      } else {
                        #if we do not have a good indication about the direction in this frame, we try to get it from the last frame
                        if (!all(is.na(skeleton_data_all[skeleton_data_all$frame == f-1 & skeleton_data_all$TrackID == t,"is_head"]))){
                          latest_head <- filter(skeleton_data_all, tp == timepoint & frame == f-1 & TrackID == t & is_head == "YES")
                          if (nrow(latest_head) == 0){
                            print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","no direction, no previous found"))
                            skeleton_data_all <<- rbind(skeleton_data_all, data_ordered_for_plotting)
                          } else {
                            latest_head_x <- latest_head$X
                            latest_head_y <- latest_head$Y
                            #here we are looking for the closest pixel that is also an end in the actual frame with respect to the previous frame
                            closest <- data_ordered_for_plotting %>%
                              mutate(latest_head_x = latest_head_x) %>%
                              mutate(latest_head_y = latest_head_y) %>%
                              mutate(distance_to_latest_head=suppressWarnings(as.numeric(mapply(distance,X,Y,latest_head_x,latest_head_y)))) %>%
                              filter(is_end == "YES") %>%
                              mutate(is_head = ifelse(distance_to_latest_head == min(distance_to_latest_head),"YES",NA)) %>%
                              filter(is_head == "YES")
                              
                            
                            data_ordered_for_plotting$is_head[closest$index] <- "YES"

                           if(!is.na(data_ordered_for_plotting[nrow(data_ordered_for_plotting),"is_head"])){
                             data_ordered_for_plotting$index <- nrow(data_ordered_for_plotting):1
                            }
                            
                            print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","no direction, head estimated from previous frame"))
                            skeleton_data_all <<- rbind(skeleton_data_all, data_ordered_for_plotting)
                            
                          }
                        
                        } else {
                          #but only it that last frame contains a head. if not (i.e. if that was missegmented), don't
                          print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","no direction, no previous found"))
                          skeleton_data_all <<- rbind(skeleton_data_all, data_ordered_for_plotting)
                         
                        }
                      }
                    }
                  
                #if skeleton contains less than 24 pixels
                } else {
                  print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","under 24 px"))
                  data_dummy <<- data_w_angles %>%
                    filter(NA) %>%
                    add_row() %>%
                    select(-c(pos,value,next_pos_1,next_pos_2)) %>%
                    mutate(index=NA, angle_1 = NA, dim_X = dim_X, dim_Y = dim_Y, prev_px_x = NA, prev_px_y = NA,next_px_x = NA, next_px_y = NA, diff_next_px_x = NA, diff_next_px_y = NA,diff_prev_px_x = NA, diff_prev_px_y = NA, is_head = NA, is_tail = NA, dataset_ID = timelapse, tp = timepoint, frame = f, TrackID = t,TrackCheck = NA)
    
                  skeleton_data_all <<- rbind(skeleton_data_all,data_dummy)
                }
              #if worm has not two ends
              } else {
                print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","has not 2 ends"))
                data_dummy <<- data_w_angles %>%
                  filter(NA) %>%
                  add_row() %>%
                  select(-c(pos,value,next_pos_1,next_pos_2)) %>%
                  mutate(index=NA, angle_1 = NA, dim_X = dim_X, dim_Y = dim_Y, prev_px_x = NA, prev_px_y = NA, next_px_x = NA, next_px_y = NA, diff_next_px_x = NA, diff_next_px_y = NA, diff_prev_px_x = NA, diff_prev_px_y = NA, is_head = NA, is_tail = NA, dataset_ID = timelapse, tp = timepoint, frame = f, TrackID = t,TrackCheck = NA)
    
                skeleton_data_all <<- rbind(skeleton_data_all,data_dummy)
              }
            #if that track does not span this frame number
            } else {
                print(paste0(timelapse,"_","tp_",timepoint,"_",t,"_","frame","_",f," ","track not detected in this frame"))
                data_dummy <<- skeleton_data_all %>%
                  filter(NA) %>%
                  mutate(tp = timepoint) %>%
                  add_row(frame=f:(max(frames))) %>%
                  mutate(index=NA, angle_1 = NA, dim_X = dim_X, dim_Y = dim_Y, is_head = NA, is_tail = NA, dataset_ID = timelapse, tp = timepoint, TrackID = t,TrackCheck = NA)
    
                skeleton_data_all <<- rbind(skeleton_data_all,data_dummy)
                break
            }
          }
        } else {
          print(paste0(t, " not present in ", timelapse, "_tp_", timepoint))
        }
      }
    }
  }
}
# timelapse <- "2019-03-26_19-27-16"
# t <- "track_2"
# timepoint <- 35
# f <- 84
# frames <- 84
```

```{r message=FALSE, include=FALSE}

# all_tracks <- as.character(unique(data$TrackID))
#function(datasetIDs, TrackIDs, tp,frames)
TrackIDs <- unique(data$TrackID)
# TrackIDs <- c("track_0","track_1","track_2","track_3","track_4","track_5","track_6","track_7","track_8","track_9","track_10")
#tps <- c(1,5,10,15,20,25,30,35,40,45,50,55,60,65,70,75,80,85,90,95,100,105,110)
tps <- unique(data$tp)

skeleton("2019-03-26_19-27-16",TrackIDs,4,0:899)

#save(skeleton_data_all, file = paste0("2019-03-26_19-27-16","_","23tps","_","0-450",".RData"))

```


# example videos of skeletons
```{r, include=FALSE}
#use this if you want only plot worms that are continuesly tracked over x frames
x <- 10

#function to plot skeletons
plot_skeletons <- function(data_plot){
  ggplot(data_plot, aes(x=X,y=Y,colour=angle_1))+
      geom_point(size=0.25) +
      geom_path(size=0.025) +
      # geom_point(aes(fill=angle_1)) +
      # transition_states(frame,transition_length = 0.1,state_length = 0.2) +
      # ease_aes('linear') + 
      #geom_text(aes(label=round(angle_1,3)),color="white",size=3,hjust=2, vjust=1)+
      geom_point(data=data_plot[which(data_plot$is_head == "YES"), ], aes(x=X, y=Y), shape=17, stroke=1, alpha=0.5,colour = "gold", size=4) +
      scale_x_continuous(limits=c(-10,70)) +
      scale_y_continuous(expan = c(0, 0),limits=c(70,-10),trans="reverse") +
      facet_wrap(~ grouping,nrow=25,ncol=35, labeller = labeller(grouping=tracknames))+
      theme_black()+
      scale_color_gradient2(low = "cornflowerblue", mid = "white",
                         high = "brown2",midpoint=0,limits=c(-1,1),na.value="grey") +
      coord_equal() +
      theme(legend.position = "none",
            axis.title=element_blank(),
            axis.ticks=element_blank(),
            axis.text=element_blank(),
            axis.line=element_blank(),
            strip.text.x = element_text(colour = 'white',size=5))+
      guides(fill=guide_legend(title="Angle (rad)"))
}



skeleton_data_all$TrackCheck_cleaned <- replace_f(skeleton_data_all$TrackCheck, 24*x)
skeleton_data_all_cleaned <- skeleton_data_all %>%
  mutate(X = ifelse(is.na(TrackCheck_cleaned), NA, X)) %>%
  mutate(Y = ifelse(is.na(TrackCheck_cleaned), NA, Y)) %>%
  mutate(grouping = paste0(dataset_ID, ",",tp,",",TrackID)) %>%
  group_by(grouping) %>%
  #only those that have a head detected at one point
  filter(any(is_head=="YES"))


# skeleton_data_all_cleaned <- skeleton_data_all %>%
#   mutate(grouping = paste0(dataset_ID, ",",tp,",",TrackID))

#if you want to look at a certain timepoint
# skeleton_data_all_cleaned <- skeleton_data_all_cleaned %>%
#   filter(tp == 4)

for (f in unique(skeleton_data_all_cleaned$frame)){
    data_plot <<- skeleton_data_all_cleaned %>%
      filter(frame == f)
   
    #tracknames <- paste(data_plot$dataset_ID,data_plot$tp,sep="\n")
    tracknames <- paste0("tp: ", data_plot$tp,"\n",data_plot$TrackID)
    data_plot$grouping <- factor(data_plot$grouping, levels=unique(data_plot$grouping))
    names(tracknames) <- data_plot$grouping
    p <-plot_skeletons(data_plot)
    
    #print(p)
    ggsave(paste0(file.path(target_folder_analysis,"ggplots"),"/",f,".png"),height = 60,width= 60,units = "cm",bg="black",dpi=150)
}



```

#show segment angle diagrams (aka "wave diagrams") next to skeleton of the same worm
```{r, include=FALSE}
#function to plot a skeleton
plot_skeleton <- function(data_plot){
  ggplot(data_plot, aes(x=X,y=Y,colour=angle_1))+
      geom_point(size=2) +
      geom_path(size=1) +
      # geom_point(aes(fill=angle_1)) +
      # transition_states(frame,transition_length = 0.1,state_length = 0.2) +
      # ease_aes('linear') + 
      #geom_text(aes(label=round(angle_1,3)),color="white",size=3,hjust=2, vjust=1)+
      geom_point(data=data_plot[which(data_plot$is_head == "YES"), ], aes(x=X, y=Y), shape=17, stroke=1, alpha=0.5,colour = "gold", size=4) +
      scale_x_continuous(limits=c(-10,70)) +
      scale_y_continuous(expan = c(0, 0),limits=c(70,-10),trans="reverse") +
      #facet_wrap(~ grouping,nrow=25,ncol=35, labeller = labeller(grouping=tracknames))+
      theme_black()+
      scale_color_gradient2(low = "cornflowerblue", mid = "white",
                         high = "brown2",midpoint=0,limits=c(-1,1),na.value="grey") +
      coord_equal() +
      theme(legend.position = "none",
            axis.title=element_blank(),
            axis.ticks=element_blank(),
            axis.text=element_blank(),
            axis.line=element_blank(),
            strip.text.x = element_text(colour = 'white',size=5))
      
}

#function to plot the wave diagram
plot_wave <- function(skeleton_wave_onetrack){
  ggplot(skeleton_wave_onetrack, aes(x=X,y=Y,fill=angle_1))+
  geom_raster(na.rm=TRUE) +
  scale_x_continuous(limits=c(0,max(skeleton_wave_onetrack$frame))) +
  scale_y_continuous(trans="reverse")+
  geom_vline(xintercept=f,linetype="longdash")+
  scale_fill_gradient2(low = "cornflowerblue",mid ="white",high = "brown2",midpoint=0,limits=c(-1,1),na.value="black") +
  theme_black()+
  theme(axis.text.y=element_blank(),
        axis.ticks.y=element_blank(),
        axis.line.y=element_blank(),
        legend.position = "top")+
  labs(x="frames",title=paste0("Timepoint: ", timepoint, ", ",unique(skeleton_wave_onetrack$TrackID)))+
  labs(y="tail                                       head")+
  theme(strip.text.x = element_text(size = 3))+
  labs(fill = "Intersegment angle (rad)")

}
  
?scale_fill_gradient2
timepoint <- 56
track <- "track_0"

#only those that have a head structure within one timepoint of choice
skeleton_wave <- skeleton_data_all %>%
  filter(tp == timepoint) %>%
  group_by(TrackID,frame) %>%
  filter(any(is_head=="YES")) %>%
  mutate(X=frame, Y=index) %>%
  mutate(grouping  = paste(tp, TrackID, sep="_"))

#present tracks with head
skeleton_wave %>%
  group_by(TrackID) %>%
  summarise(number_of_frames = length(unique(frame)))

#if you want a certain TrackID / timepoint
skeleton_wave_onetrack <- skeleton_wave %>%
  filter(TrackID == track)

skeleton_data_onetrack <- skeleton_data_all %>%
      filter(tp == timepoint) %>%
      filter(TrackID == track)


for (f in skeleton_data_onetrack %>% filter(!is.na(X)) %>% distinct(frame) %>% pull()){
  data_plot <- skeleton_data_onetrack %>%
      filter(frame == f)
   
    p1<-plot_skeleton(data_plot)
    #print(p1)
    p2 <- plot_wave(skeleton_wave_onetrack)
    #print(p2)
    plot_grid(p2,p1,align=("v"),scale=c(1,0.8))+ theme(plot.background = element_rect(fill = "black"))
    ggsave(paste0(file.path(target_folder_analysis,"ggplots"),"/","Wave_and_skeleton_","timepoint_",timepoint,"_",track,"_","frame_",f,".png"))
}


```

```{r, include=FALSE}

# 



skeleton_data_all_shuffled <- skeleton_data_all %>%
  filter(tp %in% tps_to_shuffle) %>%
  mutate(grouping=paste(dataset_ID, tp,sep="_")) %>%
  group_by(grouping) %>%
  mutate(tp = mapply(assign_new_tp,tp)) %>%
  ungroup() %>%
  select(-grouping)

  
dataframe <- skeleton_data_all
timepoints <- 50
frames <- 22

calculate_eigenvalue_contribution <- function(timepoints,dataframe,frames){
  print(timepoints)
  for_pca <- dataframe  %>%
    filter(tp %in% timepoints)  %>%
    group_by(tp,TrackID,frame) %>%
    filter(any(is_head == "YES")) %>%
    group_by(tp,TrackID) %>%
    select(angle_1,index, frame,TrackCheck,dataset_ID,TrackID,tp) %>%
    mutate(TrackCheck_cleaned = replace_f(TrackCheck, 24*frames)) %>%
    na.omit() %>%
    select(-c(TrackCheck,TrackCheck_cleaned))
  
  
  number_of_tracks <- for_pca %>%  
    ungroup() %>%
    mutate(grouping = paste(dataset_ID,tp, TrackID, sep="_")) %>%
    mutate(unique_tracks = length(unique(grouping))) %>%
    select(unique_tracks) %>%
    slice(1) %>%
    pull(unique_tracks)
  
  for_pca <- for_pca %>%
    select(-c(dataset_ID))
   

  if(nrow(for_pca) != 0){
    for_pca_t <- dcast(for_pca, index~frame+TrackID+tp,value.var = "angle_1")

    rownames(for_pca_t) <- for_pca_t$index
    for_pca_t <- select(for_pca_t, -index)
    pca <- prcomp(for_pca_t,scale=TRUE)
    # plot(pca)
    data.frame(pca$sdev^2,number_of_tracks)
  } else {
    data.frame(rep(NA,22),rep(NA,22))
    
  }
} 


dataframe <- skeleton_data_all
frames <- 22
liste <- c(49:51)
timepoints <- liste

eigenvalues_all <- map_dfc(liste,calculate_eigenvalue_contribution,dataframe,frames)
column_names <- paste0(rep(liste,each=2),rep(c("","_numberoftracks"),each=1,times=2))
colnames(eigenvalues_all) <- column_names


ev <- eigenvalues_all %>%
  select(-contains("_")) %>%
  melt() %>%
  group_by(variable) %>%
  mutate(cumsum_eigenvalue = cumsum(value)) %>%
  mutate(var_contr = cumsum_eigenvalue/sum(value)) %>%
  mutate(index = 1:n()) %>%
  filter(index %in% c(1:6))

number_of_tracks <- eigenvalues_all %>%
  select(contains("number_of_tracks
                  
                  ")) %>%
  slice(1)



ev$variable <- as.numeric(ev$variable)
ggplot(ev,aes(index,var_contr,group=variable,color=variable)) +
  geom_line() +
  geom_point()+
  scale_y_continuous(limits=c(0,1),breaks=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)) +
  scale_x_continuous(breaks=c(0,1,2,3,4,5,6)) +
  scale_color_gradientn(colours =  wes_palette("Zissou1", 40, type = "continuous")) +
  labs(x="# eigenworm", y="variance contribution (%)") +
  theme(aspect.ratio=1)
  # scale_color_viridis_c()


ev_diff <- dcast(ev,index~variable, value.var = "var_contr") %>%
  rename("early" = 2, "late" =3) %>%
  mutate(difference = abs(early - late)) %>%
  summarise(mean(difference))


assign_new_tp <- function(x){
  s[x]
}

sampling_shuffled <- function(x){
  tps_to_shuffle <- 12:69
  s <<- sample(tps_to_shuffle, length(tps_to_shuffle))
  
  dataframe_shuffled <- skeleton_data_all %>%
     filter(tp %in% tps_to_shuffle) %>%
     mutate(grouping=paste(dataset_ID, tp,sep="_")) %>%
     group_by(grouping) %>%
     mutate(tp = mapply(assign_new_tp,tp)) %>%
     ungroup() %>%
     select(-grouping)

  eigenvalues_all <- map_dfc(liste,calculate_eigenvalue_contribution,dataframe_shuffled,20)
  column_names <- paste0(rep(liste,each=2),rep(c("","_numberoftracks"),each=1,times=2))
  colnames(eigenvalues_all) <- column_names


  ev <- eigenvalues_all %>%
    select(-contains("_")) %>%
    melt() %>%
    group_by(variable) %>%
    mutate(cumsum_eigenvalue = cumsum(value)) %>%
    mutate(var_contr = cumsum_eigenvalue/sum(value)) %>%
    mutate(index = 1:n()) %>%
    filter(index %in% c(1:6)) %>%
    mutate(iteration = x)

  # number_of_tracks <- eigenvalues_all %>%
  #   select(contains("_")) %>%
  #   slice(1)
  ev
  
  
}

test <- map_dfc(1:2,sampling_shuffled)

ggplot(test %>% filter(index %in% c(1,2,3)),aes(index,var_contr,group=variable,color=iteration)) +
  # geom_line() +
  geom_point(alpha=0.05)+
  scale_y_continuous(limits=c(0,0.7),breaks=c(0.1,0.2,0.3,0.4,0.5,0.6,0.7,0.8,0.9,1)) +
  scale_x_continuous(breaks=c(0,1,2,3,4,5,6)) +
  scale_color_gradientn(colours =  wes_palette("Zissou1", 40, type = "continuous")) +
  labs(x="# eigenworm", y="variance contribution (%)") +
  theme(aspect.ratio=1)

shuffled <- dcast(test,index+iteration~variable, value.var = "var_contr") %>%
  rename("early" = 3, "late" =4) %>%
  mutate(difference = abs(early - late))



  
```




##set parameters here
```{r, include=FALSE}
#pixel to mm conversion
conversion_factor <- 6.25

#calculate_overview_statistics(offset,max_number_gaps,duration)
offset =8 #== 4 seconds
max_gaps = 0 
duration = 60 #==30 seconds
binning_factor = 10 #==5 seconds

```


```{r, include=FALSE}
#which_tracks,which_track,offset,binning_factor,conversion_factor,time_input_type,time_input,which_dataset,max_number_gaps,duration,selected_frame,color_path,image
plot_image_with_path("current_frame","track_3",8,binning_factor,conversion_factor,"minutes",18,"2019-03-06_17-56-39",0,30*2,10,"ID","no_image")
#plot_image_with_path_centered("all_frames",4*2,conversion_factor,"minutes",18,"2019-03-06_17-56-39",0,50,30*2,10,"ID","no_image")

plot_single_path_states("track_2",conversion_factor,offset,binning_factor,"minutes",700,100,"2019-03-06_17-56-39",max_gaps,duration,"path_class_binned","no_image")+
  ggsave("Path_4.png")
plot_single_path_states("track_1",conversion_factor,offset,binning_factor,"minutes",1,100,"2019-03-06_17-56-39",max_gaps,duration,"path_class_binned","no_image")


p2 <- ggplot(data_for_plotting,aes(x=frame, y=local_distance,xend=lead(frame),yend=lead(local_distance),color=state_binned))+
  geom_segment()+
  # scale_color_manual(values=rev(wes_palette(n=3, name="BottleRocket2",type="discrete")))
  scale_colour_brewer(palette="Set1")



# which_dataset <- "2019-03-06_17-56-39"
# time_input <- "278"
# color_path <- "mean_angle"
# here("Image_analysis/R/plots", which_dataset,time_input,color_path)
# path <- here("Image_analysis/R/plots", which_dataset,time_input,color_path)
# dir.create(path,recursive = TRUE)
# selected_frame <- 2
# file.path(path,paste0("tp_",selected_tp,"_",round(selected_frame,3),".png"))
# 
# 
# plot_image_with_path("current_frame",4*2,conversion_factor,"minutes",18,"2019-03-06_17-56-39",0,50,30*2,10,"ID","with_image")
#   

```

```{r, include=FALSE}
calculate_overview_statistics(conversion_factor,offset,binning_factor,max_gaps,duration)


```



##Plots1

```{r, echo=FALSE}


dfp %>%
  select(hours, dataset_ID, TrackID) %>%
  group_by(hours, dataset_ID) %>%
  summarise(.,n = n_distinct(TrackID)) %>%
  ggplot(.,aes(x=hours,y=n,fill=dataset_ID,colour=dataset_ID))+
  #scale_colour_manual(values = wes_palette("BottleRocket2"))+
  #geom_line()+
  geom_smooth(method="loess")+
  ylab("Number of tracked worms")+
  theme_classic()

data %>%
  select(hours,dataset_ID, TrackID, Duration_of_track) %>%
  group_by(hours, dataset_ID) %>%
  summarise(., mean_duration =mean(Duration_of_track)/downsampled_fps) %>%
  ggplot(.,aes(x=hours,y=mean_duration,fill=dataset_ID,colour=dataset_ID))+
  #scale_colour_manual(values = wes_palette("BottleRocket2"))+
  #geom_line()+
  geom_smooth(method="loess")+
  geom_hline(yintercept=secs_min_tracked,color="red")+
  ylab("Mean duration of tracks (seconds)")+
  theme_classic()



```


## Plot grouped images for standard parameters
```{r, echo=TRUE}

params <- grep("p\\_.+",colnames(dfp),value = TRUE)
dfp2 <- dfp %>%
  # filter(!dataset_ID %in% exps_out) %>%
  group_by(hours,dataset_ID,plate_type)%>%
  unite("experiment", c("dataset_ID","worm_type", "plate_type"), sep= " ")%>%
  group_by(experiment,hours,minutes)%>%
   summarise_at(.vars = params,
               .funs = c(mean_per_minute="mean"))


# dfp2 <- dfp %>%
#   group_by(hours,dataset_ID,plate_type)%>%
#   unite("experiment", c("dataset_ID","worm_type", "plate_type"), sep= " ")%>%
#   group_by(experiment,hours,minutes)%>%
#   summarise(turns_mean_per_minute = mean(turns_per_minute),
#             turns_mean_per_minute_ml=mean(turns_per_minute_ml),
#             size_mean_per_minute=mean(mean_size),
#             eccentricity_mean_per_minute=mean(mean_eccentricity),
#             angle_mean_per_minute=mean(mean_angle),
#             velocity_mean_per_minute=mean(mean_velocity),
#             sd_velocity_mean_per_minute=mean(sd_velocity),
#             displacement_mean_per_minute=mean(mean_displacement),
#             displacement_distance_ratio_per_minute=mean(displacement_distance_ratio))

params <- grep("p\\_.+",colnames(dfp2),value = TRUE)
for (i in params){
print(ggplot(dfp2, aes_string(x="hours",y=i))+
      #geom_ribbon(aes(ymin =  median_angle_per_minute - iqr_angle_per_minute, ymax = median_angle_per_minute + iqr_angle_per_minute))+
      geom_line(size=0.5)+
      ggtitle(i)+
      theme_classic()+
      scale_x_continuous(breaks = seq(0, max(dfp2$hours), 1))+
      facet_wrap(~experiment)+
      ggsave(paste0(i,".png"))
)
}

# 
# dfp$angle_mean_mmed <- mmed(dfp$mean_angle)
# 
# dfp2 <- dfp %>%
#   group_by(hours,dataset_ID,plate_type)%>%
#   unite("experiment", c("dataset_ID","worm_type", "plate_type"), sep= " ")%>%
#   group_by(experiment,hours,minutes)%>%
#   summarise(turns_mean_per_minute = mean(turns_per_minute), turns_mean_per_minute_ml=mean(turns_per_minute_ml), size_mean_per_minute=mean(mean_size),eccentricity_mean_per_minute=mean(mean_eccentricity),angle_mean_per_minute=mean(mean_angle),angle_mmed_mean_per_minute=mean(angle_mean_mmed),velocity_mean_per_minute=mean(mean_velocity), sd_velocity_mean_per_minute=mean(sd_velocity),displacement_mean_per_minute=mean(mean_displacement))
# 
# params <- c(params, "angle_mmed_mean_per_minute")
# for (i in params){
# print(ggplot(dfp2, aes_string(x="hours",y=i))+
#       #geom_ribbon(aes(ymin =  median_angle_per_minute - iqr_angle_per_minute, ymax = median_angle_per_minute + iqr_angle_per_minute))+
#       geom_line(size=0.5)+
#       ggtitle(i)+
#       theme_classic()+
#       scale_x_continuous(breaks = seq(0, max(dfp2$hours), 1))+
#       facet_wrap(~experiment)+
#       ggsave(paste0(i,".png"))
# )
# }

```

##Plot grouped images for standard parameters
```{r, echo=TRUE}
chosen_exps_1 <- c("2019-03-06_17-56-39",
                 "2019-03-11_17-54-09",
                 "2019-03-18_18-01-40",
                 "2019-03-19_17-40-32",
                 "2019-03-26_19-27-16",
                 "2019-03-27_18-24-47")

chosen_exps_2 <- c("2019-05-07_12-15-40", #daf2 dauer
                   "2019-04-23_17-46-08")
                   

chosen_exps_3 <- c("2019-03-25_18-10-06") #no food


chosen_exps_4 <- c("2019-05-04_15-36-42","2019-04-30_14-15-44") #L2

params <- grep("p\\_.+",colnames(dfp),value = TRUE)
sem <- function(x) sd(x)/sqrt(length(x))
for (i in params){
  dfp2 <<- dfp %>%
  filter(dataset_ID %in% chosen_exps_1 | dataset_ID %in% chosen_exps_2 | dataset_ID %in% chosen_exps_3 | dataset_ID %in% chosen_exps_4) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_1, "N2 dauers",NA)) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_2, "daf2 dauers",annotation)) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_3, "N2 dauers no food",annotation)) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_4, "L2",annotation))%>%
  #round per hour
  #mutate(hours_rounded= ceiling(hours)) %>%
  mutate(hours_rounded= ceiling(hours* 2) / 2) %>%
  group_by(annotation, hours_rounded) %>%
  summarise(parameter_mean_per_minute = mean(!!sym(i)),
            parameter_sem_per_minute = sem(!!sym(i)))

  print(ggplot(dfp2,aes(x=hours_rounded,y=parameter_mean_per_minute,color=annotation,group=annotation,palette = "jco"))+
        geom_line(size=0.75)+
        geom_point()+
        #geom_errorbar(width=.1, aes(ymin=parameter_mean_per_minute-parameter_sd_per_minute, ymax=parameter_mean_per_minute+parameter_sd_per_minute))+
        geom_ribbon(aes(ymin=parameter_mean_per_minute-parameter_sem_per_minute, ymax=parameter_mean_per_minute+parameter_sem_per_minute), fill="white",linetype = 0, alpha=0.2)+
        ggtitle(paste0(i," n=",length(c(chosen_exps_1,chosen_exps_2,chosen_exps_3))," with standard error of the mean"))+
        scale_x_continuous(breaks = seq(0, max(dfp$hours), 1))+
        xlim(0,15)+
        xlab("hours") + ylab(i)+
        theme_black()+
        scale_color_jco()+
        theme(legend.direction="vertical")+
        #theme(axis.title=element_blank(), axis.text=element_blank(), axis.ticks=element_blank(), plot.background = element_rect(fill = "black"))
        ggsave(paste0(i,"_grouped",".png"))
  )
}

```

```{r, include=FALSE}

perc <- grep("perc\\_.+",colnames(dfp),value = TRUE)
sem <- function(x) sd(x)/sqrt(length(x))
for (i in perc){
  dfp2 <<- dfp %>%
    filter(dataset_ID %in% chosen_exps_1 | dataset_ID %in% chosen_exps_2 | dataset_ID %in% chosen_exps_3 | dataset_ID %in% chosen_exps_4) %>%
    mutate(annotation = ifelse(dataset_ID %in% chosen_exps_1, paste0("\nN2 dauers\n",length(chosen_exps_1)," experiment(s)\n"),NA)) %>%
    mutate(annotation = ifelse(dataset_ID %in% chosen_exps_2,paste0("\ndaf2 dauers\n",length(chosen_exps_2)," experiment(s)\n"),annotation)) %>%
    mutate(annotation = ifelse(dataset_ID %in% chosen_exps_3, paste0("\nN2 dauers no food\n",length(chosen_exps_3)," experiment(s)\n"),annotation)) %>%
    mutate(annotation = ifelse(dataset_ID %in% chosen_exps_4, paste0("\nL2\n",length(chosen_exps_4)," experiment(s)"),annotation)) %>%
    na.omit() %>%
    mutate(hours_rounded= ceiling(hours* 2) / 2) %>%
    group_by(annotation, hours_rounded) %>%
    summarise(perc_mean_per_minute = mean(!!sym(i)),
              perc_sem_per_minute = sem(!!sym(i)))
  
  print(ggplot(dfp2,aes(x=hours_rounded,y=perc_mean_per_minute,color=annotation))+
          geom_line(size=0.75)+
          geom_point()+
          #geom_errorbar(width=.1, aes(ymin=parameter_mean_per_minute-parameter_sd_per_minute, ymax=parameter_mean_per_minute+parameter_sd_per_minute))+
          geom_ribbon(aes(ymin=perc_mean_per_minute-perc_sem_per_minute, ymax=perc_mean_per_minute+perc_sem_per_minute), fill="white",linetype = 0, alpha=0.2)+
          ggtitle(paste0(i," with standard error of the mean"))+
          scale_x_continuous(breaks = seq(0, max(dfp$hours), 1))+
          xlim(0,15)+
          xlab("hours") + ylab(i)+
          theme_black()+
          theme(legend.direction="vertical")+
          scale_color_jco()+
          ggsave(paste0(i,"_grouped_binned_states",".png"))
  )

}



```


```{r, echo=TRUE}
for (i in params){
  dfp2 <<- dfp %>%
  filter(dataset_ID %in% chosen_exps_1 | dataset_ID %in% chosen_exps_2 | dataset_ID %in% chosen_exps_3) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_1, "N2 dauers",NA)) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_2, "daf2 dauers",annotation)) %>%
  mutate(annotation = ifelse(dataset_ID %in% chosen_exps_3, "N2 dauers no food",annotation)) %>%
  mutate(time_annotation = ifelse(hours >= 0 & hours <= 2.5, "0-2.5h",NA)) %>%
  mutate(time_annotation = ifelse(hours > 2.5 & hours <= 5, "2.5-5h",time_annotation)) %>%
  mutate(time_annotation = ifelse(hours > 5 & hours <= 7.5, "5-7.5h",time_annotation)) %>%
  mutate(time_annotation = ifelse(hours > 7.5 & hours <= 10, "7.5-10h",time_annotation)) %>%
  mutate(time_annotation = ifelse(hours > 10 & hours <= 12.5, "10-12.5h",time_annotation)) %>%
  mutate(time_annotation = ifelse(hours > 12.5 & hours <= 15, "12.5-15h",time_annotation))
  
  
  print(ggboxplot(dfp2, x = "time_annotation", y = i,
          color = "annotation", palette = "jco"))
    # ggsave(paste0("p_displacement_distance_ratio","_boxplot_",".png"))

  
  
   
} 
    
```


```{r, echo=TRUE}

dfp$hours_shuffled <- sample(dfp$hours, replace = FALSE)

for (i in params){
  dfp2 <- dfp %>%
  filter(dataset_ID %in% chosen_exps) %>%
  mutate(hours_rounded= ceiling(hours_shuffled* 2) / 2) %>%
  group_by(hours_rounded)%>%
  summarise(parameter_mean_per_minute = mean(!!sym(i)),
            parameter_sd_per_minute = sem(!!sym(i)))
  
  print(ggplot(dfp2,aes(x=hours_rounded,y=parameter_mean_per_minute))+
        geom_line(size=0.5,color="blue")+
        #geom_errorbar(width=.1, aes(ymin=parameter_mean_per_minute-parameter_sd_per_minute, ymax=parameter_mean_per_minute+parameter_sd_per_minute))+
        geom_ribbon(aes(ymin=parameter_mean_per_minute-parameter_sd_per_minute, ymax=parameter_mean_per_minute+parameter_sd_per_minute), alpha=0.3)+
        ggtitle(paste0(i," n=",length(chosen_exps)," with standard error of the mean"))+
        theme_classic()+
        scale_x_continuous(breaks = seq(0, max(dfp$hours), 1))+
        xlab("hours") + ylab(i)
        #ggsave(paste0(i,".png"))
  )
}       


```

## Cumulative distributions over time average over all datasets

```{r, echo=TRUE}


for (i in params){
  dfp2 <- dfp %>%
    filter(dataset_ID %in% chosen_exps_1 | dataset_ID %in% chosen_exps_2 | dataset_ID %in% chosen_exps_3 | dataset_ID %in% chosen_exps_4) %>%
    mutate(hours_rounded= ceiling(hours* 2) / 2) %>%
    group_by(worm_type) %>%
    mutate(N=paste0(worm_type, " N= ",n_distinct(dataset_ID), " datasets"))
  
  for(w in unique(dfp2$worm_type)){
    dfp3 <- dfp2 %>%
      filter(worm_type == w) %>%
      group_by(hours_rounded) %>%
      mutate(N_worms= n()) %>%
      ungroup() %>%
      mutate(sd_N_worms=sd(N_worms))%>%
      mutate(mean_N_worms=mean(N_worms))
  
    print(ggplot(dfp3,aes_string(x = i, y = "hours_rounded",group="hours_rounded",height="..density.."))+
      geom_density_ridges_gradient(aes(fill = ..x..), scale = 5, size = 0.3) +
      scale_fill_gradientn(colours = c("#0D0887FF", "#CC4678FF", "#F0F921FF"))+
      scale_x_continuous(limits = c(0, NA)) +
      theme_black()+
      theme(legend.position = "none")+
      ggtitle(paste0(gsub("p\\_(.+)","\\1",i)," ",w, " ", round(dfp3$mean_N_worms,0), "+-", round(dfp3$sd_N_worms,0)))+
      ggsave(paste0(i,"_",w,"_distribution",".png")))
  }

}


```

## Plot gifs of parameters
```{r, echo=TRUE, out.width = '4%'}

for (i in params){
  dfp2 <- dfp %>%
  filter(dataset_ID %in% chosen_exps) %>%
  mutate(hours_rounded= ceiling(hours* 2) / 2) %>%
  group_by(hours_rounded)%>%
  summarise(parameter_mean_per_minute = mean(!!sym(i)),
            parameter_sd_per_minute = sem(!!sym(i)))
  
  print(ggplot(dfp2,aes(x=hours_rounded,y=parameter_mean_per_minute))+
        geom_line(size=0.5,color="blue")+
        #geom_errorbar(width=.1, aes(ymin=parameter_mean_per_minute-parameter_sd_per_minute, ymax=parameter_mean_per_minute+parameter_sd_per_minute))+
        geom_ribbon(aes(ymin=parameter_mean_per_minute-parameter_sd_per_minute, ymax=parameter_mean_per_minute+parameter_sd_per_minute), alpha=0.3)+
        ggtitle(paste0(i," n=",length(chosen_exps)," with standard error of the mean"))+
        theme_classic()+
        scale_x_continuous(breaks = seq(0, max(dfp$hours), 1))+
        xlab("hours") + ylab(i)
        #ggsave(paste0(i,".png"))
  )
}           
chosen_dataset <- "2019-01-23_16-07-02"
dfp2 <- dfp %>%
  group_by(minutes,dataset_ID,plate_type,tp)%>%
  filter(mean_displacement > 100)%>%
  summarise(size_median_per_minute=median(mean_size),eccentricity_median_per_minute=median(mean_eccentricity),angle_median_per_minute=median(mean_angle),velocity_median_per_minute=median(mean_velocity), sd_velocity_median_per_minute=median(sd_velocity),displacement_median_per_minute=median(mean_displacement))%>%
  filter(dataset_ID == chosen_dataset)

for (i in dfp2$tp){
  
dfp3 <- dfp2 %>%
    filter(tp <= i)
  
  p1 <- ggplot(dfp3,aes_string(x="minutes",y="angle_median_per_minute"))+
      geom_line(size=1,color="white")+
      scale_x_continuous(limits=c(0, max(dfp2$minutes)))+
      scale_y_continuous(limits=c(0, max(dfp2$angle_median_per_minute)))+
      xlab("")+
      ylab("median\nangle")+
      theme_black()+
      theme(axis.title.x = element_text(size = rel(1.5)),
            axis.title.y = element_text(size = rel(1.5)))       
  
#plot_image_with_path(offset,selected_minute,which_dataset,max_number_gaps,duration,which_frame,color_path,with_image) 
  p2 <- plot_image_with_path(5,"tp",i,chosen_dataset,5,100,1,"mean_angle","no")+theme_black()+xlab("")+ylab("")+
      theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(),
        legend.key.height=unit(0.5,"line"))


  p3 <- ggplot(dfp3,aes_string(x="minutes",y="velocity_median_per_minute"))+
      geom_line(size=1,color="white")+
      scale_x_continuous(limits=c(0, max(dfp2$minutes)))+
      scale_y_continuous(limits=c(0, max(dfp2$velocity_median_per_minute)))+
      xlab("")+
      ylab("median\nvelocity")+
      theme_black()+
      theme(axis.title.x = element_text(size = rel(1.5)),
            axis.title.y = element_text(size = rel(1.5)))  

  p4 <- plot_image_with_path(5,"tp",i,chosen_dataset,5,100,1,"velocity","no")+theme_black()+xlab("")+ylab("")+
      theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(),
        legend.key.height=unit(0.5,"line"))

  
  p5 <- ggplot(dfp3,aes_string(x="minutes",y="displacement_median_per_minute"))+
      geom_line(size=1,color="white")+
      scale_x_continuous(limits=c(0, max(dfp2$minutes)))+
      scale_y_continuous(limits=c(0, max(dfp2$displacement_median_per_minute)))+
      xlab("minutes")+
      ylab("median\ndisplacement")+
      theme_black()+
      theme(axis.title.x = element_text(size = rel(1.5)),
            axis.title.y = element_text(size = rel(1.5)))  
  
  p6 <- plot_image_with_path(5,"tp",i,chosen_dataset,5,100,1,"displacement","no")+theme_black()+xlab("")+ylab("")+
      theme(axis.title=element_blank(),
        axis.text=element_blank(),
        axis.ticks=element_blank(),
        legend.key.height=unit(0.5,"line"))

  
 p_all <- plot_grid(p1, p2, p3,p4,p5,p6,
          ncol = 2, nrow = 3,
          rel_widths = c(1,1))

 p_all
 save_plot(paste0("plots/",chosen_dataset,"_",round(i,3),".png"), p_all, base_height=10,base_aspect_ratio = 1.1)
 print(paste0("Saved plot Nr.",round(i,3)))
 
}


```


```{r, echo=TRUE}
###check if this function is up to date
#plot_image_with_path_centered(which_tracks,offset,conversion_factor,time_input_type,time_input,which_dataset,max_number_gaps,duration,selected_frame,color_path,image)
plot_image_with_path_centered("all_frames",secs_angle_offset*downsampled_fps,conversion_factor,"minutes",129,"2019-03-06_17-56-39",max_gaps,secs_min_tracked*downsampled_fps,10, "mean_angle","no_image")

minutes <- dfp %>%
  filter(dataset_ID == "2019-03-06_17-56-39")

minutes_unique <- unique(minutes$minutes)
minutes_unique
minutes_length <- length(minutes_unique)
minutes_length
```


```{r, echo=TRUE}

for (i in (minutes_unique)){
  plot_image_with_path_centered("all_frames",secs_angle_offset*downsampled_fps,conversion_factor,"minutes",i,"2019-03-06_17-56-39",max_gaps,secs_min_tracked*downsampled_fps,10, "mean_angle","no_image")
  save_plot(paste0("plots/","centered_",sprintf("%03d", i),".png"),pc,base_height=10,base_aspect_ratio = 1.1)
  print(paste0("Saved plot for minute ",sprintf("%03d", i)))
}

```



```{r, echo=TRUE}
dfp2 <- dfp %>%
  group_by(minutes,dataset_ID,plate_type)%>%
  unite("experiment", c("dataset_ID","plate_type"), sep= " ")

ggplot(dfp2,aes(x = mean_angle, y = mean_velocity))+
  stat_density2d(geom="raster", aes(fill = ..density..),contour = FALSE)+
  scale_fill_viridis(option = "inferno")+
  scale_x_reverse(limits=c(180,0), breaks = seq(180, 0, by = -36))+
  scale_y_continuous(limits=c(0,15), breaks = seq(0,15, by = 5))+
  theme_classic2()+
  ggtitle("2D density velocity against angle velocity")+
  facet_wrap(~experiment)

```


```{r, echo=TRUE}
test <- MASS::geyser

data <- data.frame(dfp2$mean_angle,dfp2$mean_velocity)
colnames(data) <- c("mean_angle","mean_velocity")
data
kd <- with(data, MASS::kde2d(mean_angle,mean_velocity, n = 50))
p <- plot_ly(x = kd$x, y = kd$y, z = kd$z) %>% add_surface()
p
chart_link = api_create(p, filename="surface-2")
chart_link

```


