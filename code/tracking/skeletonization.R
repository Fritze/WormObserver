# Use this script after running the "data_grouping.R" script that summarises the data for a given condition.
# Needed: A metadata file that is located in the folder that contains the "raw_data.RDS" files generated by the "data_grouping.R" (i.e. the directory that contains the acquired experiments)
# This file should be named "toprocess_skeletonization.txt" and contain the conditions you want to skeletonize.
# Additionally you have to specify the conversion factor (the number of micrometers that correspond to one pixel at your given magnification, i.e. 6.25).
# Please also specify the first and last timepoint that should be skeletonized. 
# To run the script type: Rscript skeletonization.R "the location of your raw data folder" "conversion factor" "first timepoint" "last timepoint"
# e.g. Rscript skeletonization.R /media/fpreuss/raid5/timelapses/analysis/paper/data/raw 6.25 1 90

library("tidyverse")
library("data.table")
library("reshape2")
library("pracma")

###### functions ######
#1 Small helper functions

# used to calculate angles describing the worm path
angle1 <- function(x1, y1, x2, y2) {
  values <- list(x1, y1, x2, y2)
  if(anyNA(values)) {
    "NA"
  } else {
    x <- c(x1, y1)
    y <- c(x2, y2)
    dot.prod <- x%*%y
    norm.x <- norm(x,type="2")
    norm.y <- norm(y,type="2")
    theta <- acos(dot.prod / (norm.x * norm.y))
    as.numeric(theta)
  }
}

# used to calculate angles between worm segments
angle2 <- function(x1, y1, x2, y2) {
  atan2(y2,x2) - atan2(y1,x1) 
}

# used to calculate distance change for estimating speed
distance <- function(x1, y1, x2, y2) {
  values <- list(x1, y1, x2, y2)
  if(anyNA(values)) {
    "NA"
  } else {
    length <- sqrt((x1-x2)^2+(y1-y2)^2)
    as.numeric(length)
  }
}

# the function which will change all values of a given column to NA, except those rows that are consecutive for y times
replace_f <- function(x,y){
  subs <- rle(x)
  subs$values[subs$lengths < y] <- NA
  inverse.rle(subs)
}

#2 functions for skeletonization
skeleton_direction <- function(x){
  mutate(x,x_lag=lag(location_x,n=1) - location_x, y_lag = lag(location_y, n=1) - location_y) %>%
    mutate(x_lead=lead(location_x, n=1) - location_x, y_lead=lead(location_y, n=1) - location_y) %>%
    #calculate local distance for velocity (difference between position n and position n-1 second (i.e. 2 frames))
    mutate(local_distance=suppressWarnings(as.numeric(mapply(distance,lag(location_x,n=2),lag(location_y,n=2),location_x,location_y)))) %>%
    # this will result in velocity based on local distance (µm/s)
    mutate(velocity = local_distance*conversion_factor/downsampled_to) %>%
    mutate(x_dir = ifelse(x_lead < 0, "left","right")) %>%
    mutate(y_dir = ifelse(y_lead < 0, "up","down")) %>%
    mutate(direction = paste(x_dir,y_dir,sep="-")) %>%
    mutate(direction = ifelse(velocity > 10,direction, NA)) %>%
    #only keep the direction when direction and speed > 10µm/s is stable over 2.5 seconds
    mutate(direction = replace_f(direction,5))
  
}




skeleton_frame <- function(data){
  #get dimension from table, variables bitmask_dim_Y and bitmask_dim_X
  dim_Y <- data$bitmask_dim_Y
  dim_X <- data$bitmask_dim_X
  # #import the data from bitmask column and transform to matrix with right dimensions
  bitmask <- data$bitmask
  bitmask <- strsplit(as.character(unlist(bitmask)),",")
  bitmask <- as.numeric(unlist(lapply(bitmask,gsub,pattern=".*(\\d+)\\..+", replacement="\\1")))
  data_imported <- matrix(bitmask,nrow=dim_Y, byrow=TRUE)
  
  # #add 2 columns and 2 frames (as a "frame" around the bitmask)
  data_imported <- rbind(data_imported, rep(0,ncol(data_imported)))
  data_imported <- rbind(rep(0,ncol(data_imported)),data_imported)
  data_imported <- cbind(rep(0, nrow(data_imported)),data_imported)
  data_imported <- cbind(data_imported,rep(0, nrow(data_imported)))
  #
  #
  #add two to get the new dimensions right
  dim_X <- data$bitmask_dim_X + 2
  dim_Y <- data$bitmask_dim_Y + 2
  
  data_imported <- data_imported %>%
    melt(.) %>%
    rename(Y = 1, X = 2,value = 3) %>%
    mutate(next_px_1_x = 0, next_px_1_y = 0,
           next_px_2_x = 0, next_px_2_y = 0)
  
  
  #this is a ggplot to check if the skeleton was imported right
  # ggplot(data_imported %>% filter(value==1), aes(x=X,y=Y))+
  #     coord_equal() +
  #     geom_raster(aes(fill="black"))+
  #     scale_x_continuous(expand = c(0, 0), limits= c(0,dim_X)) +
  #     scale_y_continuous(expand = c(0, 0),trans="reverse") +
  #     # theme_void()+
  #     theme(legend.position="none")
  
  pixel_list <- vector(mode="list",length=0)
  rows_with_value1 <- data_imported %>%
    mutate(original_rownumber=1:n()) %>%
    filter(value == 1) %>%
    pull(original_rownumber)
  
  
  for(i in rows_with_value1){
    
    #look for surrounding pixels of those pixels that have value == 1
    if(data_imported[i+1,"value"] == 1){#0°
      pixel_list <- append(pixel_list,paste(data_imported[i+1,"X"],data_imported[i+1,"Y"], sep=","))}
    if(data_imported[i+dim_Y+1,"value"] == 1){#45°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y+1,"X"],data_imported[i+dim_Y+1,"Y"], sep=","))}
    if(data_imported[i+dim_Y,"value"] == 1){#90°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y,"X"],data_imported[i+dim_Y,"Y"], sep=","))}
    if(data_imported[i+dim_Y-1,"value"] == 1){#135°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y-1,"X"],data_imported[i+dim_Y-1,"Y"], sep=","))}
    if(data_imported[i-1,"value"] == 1){#180°
      pixel_list <- append(pixel_list,paste(data_imported[i-1,"X"],data_imported[i-1,"Y"], sep=","))}
    if(data_imported[i-dim_Y-1,"value"] == 1){#225°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y-1,"X"],data_imported[i-dim_Y-1,"Y"], sep=","))}
    if(data_imported[i-dim_Y,"value"] == 1){#270°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y,"X"],data_imported[i-dim_Y,"Y"], sep=","))}
    if(data_imported[i-dim_Y+1,"value"] == 1){#315°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y+1,"X"],data_imported[i-dim_Y+1,"Y"], sep=","))}
    
    
    #if only one neighbouring pixel is found then it most likely corresponds to the end (head or tail of the worm)
    if(length(pixel_list) == 1 ){
      data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
      data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
      data_imported[i,"is_end"] <- "YES"
      pixel_list <- vector(mode="list",length=0)
      #if there are more than one neighbouring pixels than the pixel in question sits somewhere in the middle
      #so far we only account for more than  two neighbours ...
    } else if(length(pixel_list) > 1){
      data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
      data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
      data_imported[i,"next_px_2_x"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[1])
      data_imported[i,"next_px_2_y"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[2])
      data_imported[i,"is_end"] <- "NO"
      pixel_list <- vector(mode="list",length=0)
    }
  }
  
  
  
  # if there is no pixel found with any neighbours set all pixels to is_end == "NO"
  if (is.null(data_imported$is_end)){
    data_imported$is_end <- "NO"
  }
  
  data_w_angles <- data_imported %>%
    #only pixels that have value 1 (== no background)
    filter(value == 1) %>%
    #make sure that one endpoint is at the top of the table
    arrange(desc(is_end)) %>%
    #group positions (actual and neighbouring ones to one string)
    mutate(pos = paste(X,Y,sep=",")) %>%
    mutate(next_pos_1 = paste(next_px_1_x,next_px_1_y,sep=",")) %>%
    mutate(next_pos_2 = paste(next_px_2_x,next_px_2_y,sep=",")) %>%
    mutate(direction = data$direction) %>%
    mutate(direction = ifelse(is.na(direction), "no direction",direction)) %>%
    mutate(x_dir = data$x_dir) %>%
    mutate(x_dir = ifelse(is.na(x_dir), "no direction",x_dir)) %>%
    mutate(y_dir = data$y_dir) %>%
    mutate(y_dir = ifelse(is.na(y_dir), "no direction",y_dir)) %>%
    mutate(location_x = data$location_x) %>%
    mutate(location_y =data$location_y) %>%
    select(-c(next_px_1_x,next_px_1_y,next_px_2_x,next_px_2_y))
  
  #only do the following for worms that have 2 ends
  if(length(data_w_angles[data_w_angles$is_end == "YES","is_end"]) == 2){
    #start from one end (because we ordered by is_end above)
    pos_list <- data_w_angles[1, "pos"]
    
    
    # looks for the next position until the next end is found
    #if there is a round structure this can go into a endless loop, therefore don't make the list longer than the total number of pixels with value == 1
    while(tail(pos_list, n=1) != "0,0" && length(pos_list) < length(data_w_angles$value)){
      next_pos <- data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_1"]
      if(next_pos %in% pos_list){
        pos_list <- append(pos_list, data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_2"])
      }else{
        pos_list <- append(pos_list, next_pos)
      }
      if(length(unique(pos_list)) != length(pos_list)){
        pos_list <- NA
        break
      }
    }
    
    
    
    #only save those if there are more than 26 pixels and smaller than 60
    if(length(pos_list) > 26 & length(pos_list) < 80){
      
      #order pixels in the right order
      data_ordered <- data_w_angles[match(pos_list, data_w_angles$pos),] %>%
        na.omit
      
      #downsample to 26
      knots_Y <- linspace(data_ordered$Y[1],data_ordered$Y[nrow(data_ordered)],nrow(data_ordered))
      knots_X <- linspace(data_ordered$X[1],data_ordered$X[nrow(data_ordered)],nrow(data_ordered))
      tryCatch({
        cfit <<- curvefit(knots_X, data_ordered$X, data_ordered$Y,8)
        px <- c(cfit$px)
        py <- c(cfit$py)
        downsampled_knots <<- linspace(data_ordered$X[1],data_ordered$X[nrow(data_ordered)],26)
      },
      error = function(e){
        cfit <<- "no X fit"
      })
      
      if (!is.list(cfit)){
        tryCatch({
          cfit <<- curvefit(knots_Y, data_ordered$X, data_ordered$Y,8)
          px <- c(cfit$px)
          py <- c(cfit$py)
          downsampled_knots <<- linspace(data_ordered$Y[1],data_ordered$Y[nrow(data_ordered)],26)
        },
        error  = function(e2){
          cfit <<- "no X and Y fit"
        })
      }
      
      if (!is.list(cfit)){
        data_w_angles %>%
          filter(NA) %>%
          add_row() %>%
          select(-c(pos,value,next_pos_1,next_pos_2)) %>%
          mutate(location_x = data$location_x) %>%
          mutate(location_y =data$location_y) %>%
          mutate(index=NA, angle = NA, dim_X = dim_X, dim_Y = dim_Y, prev_px_x = NA, prev_px_y = NA,next_px_x = NA, next_px_y = NA, diff_next_px_x = NA, diff_next_px_y = NA, diff_prev_px_x = NA, diff_prev_px_y = NA, is_head = NA, is_tail = NA,TrackCheck = NA) %>%
          mutate(status = "error when fitting polynomial")
        
        
      } else {
        xs <- polyval(px, downsampled_knots)
        ys <- polyval(py, downsampled_knots)
        
        #get first and last position to is_end == "YES" (order should be the same as before so we can assume end of dataframe=end of worm)
        data_ordered_downsampled <- data.frame(cbind(xs,ys))
        data_ordered_downsampled$is_end <- NA
        data_ordered_downsampled$is_end[1] <- "YES"
        data_ordered_downsampled$is_end[26] <- "YES"
        
        #add index number for each pixel
        data_ordered_downsampled %>%
          rename("X" = 1, "Y" = 2) %>%
          mutate(index = row_number()) %>%
          mutate(next_px_x = lead(X,n=1), next_px_y = lead(Y,n=1)) %>%
          mutate(prev_px_x = lag(X,n=1),prev_px_y = lag(Y,n=1)) %>%
          mutate(diff_prev_px_x =  X - prev_px_x, diff_prev_px_y = Y - prev_px_y) %>%
          mutate(diff_next_px_x = next_px_x - X, diff_next_px_y = next_px_y - Y) %>%
          mutate(angle=suppressWarnings(as.numeric(mapply(angle2,diff_prev_px_x,diff_prev_px_y,diff_next_px_x,diff_next_px_y))))%>%
          mutate(dim_X = dim_X, dim_Y = dim_Y) %>%
          mutate(is_head = NA) %>%
          mutate(is_tail = NA) %>%
          mutate(TrackCheck= data$TrackID) %>%
          mutate(direction = data$direction) %>%
          mutate(x_dir = data$x_dir) %>%
          mutate(y_dir = data$y_dir) %>%
          mutate(location_x = data$location_x) %>%
          mutate(location_y =data$location_y) %>%
          mutate(status = "downsampled to 26 pixels with 2 ends")
      }
    } else {
      data_w_angles %>%
        filter(NA) %>%
        add_row() %>%
        select(-c(pos,value,next_pos_1,next_pos_2)) %>%
        mutate(location_x = data$location_x) %>%
        mutate(location_y =data$location_y) %>%
        mutate(index=NA, angle = NA, dim_X = dim_X, dim_Y = dim_Y, prev_px_x = NA, prev_px_y = NA,next_px_x = NA, next_px_y = NA, diff_next_px_x = NA, diff_next_px_y = NA,diff_prev_px_x = NA, diff_prev_px_y = NA, is_head = NA, is_tail = NA,TrackCheck = NA) %>%
        mutate(status = "under 26 px")
    }
  } else {
    data_w_angles %>%
      filter(NA) %>%
      add_row() %>%
      select(-c(pos,value,next_pos_1,next_pos_2)) %>%
      mutate(location_x = data$location_x) %>%
      mutate(location_y =data$location_y) %>%
      mutate(index=NA, angle = NA, dim_X = dim_X, dim_Y = dim_Y, prev_px_x = NA, prev_px_y = NA,next_px_x = NA, next_px_y = NA, diff_next_px_x = NA, diff_next_px_y = NA,diff_prev_px_x = NA, diff_prev_px_y = NA, is_head = NA, is_tail = NA,TrackCheck = NA) %>%
      mutate(status = "not 2 ends")
    
  }
  
}

# this function is adapted from the skeleton frame function above
# but it just counts number of pixels of the midline of the worm, if skeleton is unclear, no count
count_midline_pixels <- function(data){
  #get dimension from table, variables bitmask_dim_Y and bitmask_dim_X
  dim_Y <- data$bitmask_dim_Y
  dim_X <- data$bitmask_dim_X
  # #import the data from bitmask column and transform to matrix with right dimensions
  bitmask <- data$bitmask
  bitmask <- strsplit(as.character(unlist(bitmask)),",")
  bitmask <- as.numeric(unlist(lapply(bitmask,gsub,pattern=".*(\\d+)\\..+", replacement="\\1")))
  data_imported <- matrix(bitmask,nrow=dim_Y, byrow=TRUE)
  
  # #add 2 columns and 2 frames (as a "frame" around the bitmask)
  data_imported <- rbind(data_imported, rep(0,ncol(data_imported)))
  data_imported <- rbind(rep(0,ncol(data_imported)),data_imported)
  data_imported <- cbind(rep(0, nrow(data_imported)),data_imported)
  data_imported <- cbind(data_imported,rep(0, nrow(data_imported)))
  #
  #
  #add two to get the new dimensions right
  dim_X <- data$bitmask_dim_X + 2
  dim_Y <- data$bitmask_dim_Y + 2
  
  data_imported <- data_imported %>%
    melt(.) %>%
    rename(Y = 1, X = 2,value = 3) %>%
    mutate(next_px_1_x = 0, next_px_1_y = 0,
           next_px_2_x = 0, next_px_2_y = 0)
  
  
  # this is a ggplot to check if the skeleton was imported right
  # ggplot(data_imported %>% filter(value==1), aes(x=X,y=Y))+
  #   coord_equal() +
  #   geom_tile(fill="red",color="black") +
  #   scale_x_continuous(expand = c(0, 0), limits= c(0,dim_X)) +
  #   scale_y_continuous(expand = c(0, 0),trans="reverse") +
  #   theme(legend.position="none")+
  #   ggsave("test.png")
  
  pixel_list <- vector(mode="list",length=0)
  rows_with_value1 <- data_imported %>%
    mutate(original_rownumber=1:n()) %>%
    filter(value == 1) %>%
    pull(original_rownumber)
  
  
  for(i in rows_with_value1){
    
    #look for surrounding pixels of those pixels that have value == 1
    if(data_imported[i+1,"value"] == 1){#0°
      pixel_list <- append(pixel_list,paste(data_imported[i+1,"X"],data_imported[i+1,"Y"], sep=","))}
    if(data_imported[i+dim_Y+1,"value"] == 1){#45°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y+1,"X"],data_imported[i+dim_Y+1,"Y"], sep=","))}
    if(data_imported[i+dim_Y,"value"] == 1){#90°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y,"X"],data_imported[i+dim_Y,"Y"], sep=","))}
    if(data_imported[i+dim_Y-1,"value"] == 1){#135°
      pixel_list <- append(pixel_list,paste(data_imported[i+dim_Y-1,"X"],data_imported[i+dim_Y-1,"Y"], sep=","))}
    if(data_imported[i-1,"value"] == 1){#180°
      pixel_list <- append(pixel_list,paste(data_imported[i-1,"X"],data_imported[i-1,"Y"], sep=","))}
    if(data_imported[i-dim_Y-1,"value"] == 1){#225°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y-1,"X"],data_imported[i-dim_Y-1,"Y"], sep=","))}
    if(data_imported[i-dim_Y,"value"] == 1){#270°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y,"X"],data_imported[i-dim_Y,"Y"], sep=","))}
    if(data_imported[i-dim_Y+1,"value"] == 1){#315°
      pixel_list <- append(pixel_list,paste(data_imported[i-dim_Y+1,"X"],data_imported[i-dim_Y+1,"Y"], sep=","))}
    
    
    #if only one neighbouring pixel is found then it most likely corresponds to the end (head or tail of the worm)
    if(length(pixel_list) == 1 ){
      data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
      data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
      data_imported[i,"is_end"] <- "YES"
      pixel_list <- vector(mode="list",length=0)
      #if there are more than one neighbouring pixels than the pixel in question sits somewhere in the middle
      #so far we only account for more than  two neighbours ...
    } else if(length(pixel_list) > 1){
      data_imported[i,"next_px_1_x"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[1])
      data_imported[i,"next_px_1_y"] <- as.numeric(unlist(strsplit(pixel_list[[1]],split=","))[2])
      data_imported[i,"next_px_2_x"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[1])
      data_imported[i,"next_px_2_y"] <- as.numeric(unlist(strsplit(pixel_list[[2]],split=","))[2])
      data_imported[i,"is_end"] <- "NO"
      pixel_list <- vector(mode="list",length=0)
    }
  }
  
  
  
  # if there is no pixel found with any neighbours set all pixels to is_end == "NO"
  if (is.null(data_imported$is_end)){
    data_imported$is_end <- "NO"
  }
  
  data_w_angles <- data_imported %>%
    #only pixels that have value 1 (== no background)
    filter(value == 1) %>%
    #make sure that one endpoint is at the top of the table
    arrange(desc(is_end)) %>%
    #group positions (actual and neighbouring ones to one string)
    mutate(pos = paste(X,Y,sep=",")) %>%
    mutate(next_pos_1 = paste(next_px_1_x,next_px_1_y,sep=",")) %>%
    mutate(next_pos_2 = paste(next_px_2_x,next_px_2_y,sep=",")) %>%
    mutate(direction = data$direction) %>%
    mutate(direction = ifelse(is.na(direction), "no direction",direction)) %>%
    mutate(x_dir = data$x_dir) %>%
    mutate(x_dir = ifelse(is.na(x_dir), "no direction",x_dir)) %>%
    mutate(y_dir = data$y_dir) %>%
    mutate(y_dir = ifelse(is.na(y_dir), "no direction",y_dir)) %>%
    mutate(location_x = data$location_x) %>%
    mutate(location_y =data$location_y) %>%
    select(-c(next_px_1_x,next_px_1_y,next_px_2_x,next_px_2_y))
  
  #only do the following for worms that have 2 ends
  if(length(data_w_angles[data_w_angles$is_end == "YES","is_end"]) == 2){
    #start from one end (because we ordered by is_end above)
    pos_list <- data_w_angles[1, "pos"]
    
    
    # looks for the next position until the next end is found
    #if there is a round structure this can go into a endless loop, therefore don't make the list longer than the total number of pixels with value == 1
    while(tail(pos_list, n=1) != "0,0" && length(pos_list) < length(data_w_angles$value)){
      next_pos <- data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_1"]
      if(next_pos %in% pos_list){
        pos_list <- append(pos_list, data_w_angles[which(data_w_angles$pos == tail(pos_list, n=1)),"next_pos_2"])
      }else{
        pos_list <- append(pos_list, next_pos)
      }
      if(length(unique(pos_list)) != length(pos_list)){
        pos_list <- NA
        break
      }
    }
    
    data <- data %>%
      mutate(midline_length = length(pos_list))
    
  } else {
    data <- data %>%
      mutate(midline_length = NA)
    
  }
  
}



skeleton_head <- function(data){
  #if for that frame we have an idea about the direction in which the worm moves (see above), we will try finding a head structure based on this
  if(!is.na(unique(data$direction))){
    
    #for this frame get moving direction
    x_dir <- unique(data$x_dir)
    y_dir <- unique(data$y_dir)
    #get only pixels that describe the end of the worm
    worm_ends <- filter(data, is_end == "YES")
    
    #here depending on the direction in which the worm moves in the field of view (for X= right or left, for Y=up or down) we translate this information to the bitmask and identify the pixel that is closest to this side
    if (x_dir == "right" && y_dir == "up"){
      data <- data %>%
        mutate(is_head = NA) %>%
        mutate(is_head = ifelse(X == max(worm_ends$X) & Y == min(worm_ends$Y)  & is_end == "YES","YES", NA))
      
    } else if (x_dir == "left" && y_dir == "up"){
      data <- data %>%
        mutate(is_head = NA) %>%
        mutate(is_head = ifelse(X == min(worm_ends$X) & Y == min(worm_ends$Y)  & is_end == "YES","YES", NA))
      
    } else if (x_dir == "right" && y_dir == "down"){
      data <- data %>%
        mutate(is_head = NA) %>%
        mutate(is_head = ifelse(X == max(worm_ends$X) & Y == max(worm_ends$Y)  & is_end == "YES","YES", NA))
      
    } else if (x_dir == "left" && y_dir == "down"){
      data <- data %>%
        mutate(is_head = NA) %>%
        mutate(is_head = ifelse(X == min(worm_ends$X) & Y == max(worm_ends$Y)  & is_end == "YES","YES", NA))
    }
    
    #if head is at then end then switch index positions
    if(!is.na(data[nrow(data),"is_head"])){
      data$index <- nrow(data):1
    }
    
    if(all(is.na(data$is_head))){
      data <- data %>%
        mutate(status = "Head position unclear.")  
    } else {
      data <- data %>%
        mutate(status = "Head detected.")
    }
    
    
  } else {
    data <- data
  }
  
}

skeleton_head_estimate <- function(data) {
  
  n <- filter(data, head_to_be_estimated == "NO") %>%
    select(frame) %>%
    distinct() %>%
    pull()
  
  ny <- filter(data,head_to_be_estimated == "YES") %>%
    select(frame) %>%
    distinct() %>%
    pull()
  
  for (i in 1:10^3){
    #detect frames where head is detected (for particular track)
    s <- filter(data,!is.na(is_head)) %>%
      select(frame) %>%
      distinct() %>%
      pull()
    #list of adjacent frames to ones with head
    list_of_frames <- c(setdiff(s-1,s),setdiff(s+1,s))
    #only those that are NOT within the list of head_to_be_estimated == "NO"
    list_of_frames_to_be_detected <- setdiff(list_of_frames,n)
    #only those that are within the list of frames that span the track
    list_of_frames_to_be_detected <- intersect(list_of_frames_to_be_detected,unique(data$frame))
    if (length(list_of_frames_to_be_detected) > 0){
      f <- list_of_frames_to_be_detected[1]
      #select frame where to estimate head, looking for an adjacent frame where the head is detected
      adjacent_f <- s[which(abs(s-f)==min(abs(s-f)))][1]
      
      #get X and Y coordinates from the adjacent head
      XX <- filter(data, frame == adjacent_f & is_head == "YES") %>% pull(X)
      YY <- filter(data, frame == adjacent_f & is_head == "YES") %>% pull(Y)
      data <- data %>%
        ungroup() %>%
        #identify the five segments that are beginning or end
        mutate(end_segment = ifelse(frame == f & index %in% c(1:5),"one",NA)) %>%
        mutate(end_segment = ifelse(frame == f & index %in% c((max(data$index,na.rm=TRUE)-5):max(data$index,na.rm=TRUE)),"two",end_segment)) %>%
        #calculate distance distance between end segments and latest head
        mutate(distance_to_latest_head=ifelse(frame == f  & end_segment %in% c("one","two"),suppressWarnings(as.numeric(mapply(distance,X,Y,XX,YY))),NA )) %>%
        group_by(end_segment) %>%
        #calculate the median distance between these 5 end segments on each side
        mutate(distance_to_latest_head =  median(distance_to_latest_head,na.rm =TRUE)) %>%
        ungroup() %>%
        #the end point of the segment (beginning or end) that has the minimal distance to the old head will be new head
        mutate(is_head = if_else(distance_to_latest_head == suppressWarnings(min(distance_to_latest_head,na.rm=TRUE)) & frame == f & is_end == "YES", "YES", is_head)) %>%
        mutate(distance_to_latest_head = NA) %>%
        select(-end_segment) %>%
        mutate(head_to_be_estimated=if_else(frame == f,"DONE",head_to_be_estimated)) %>%
        mutate(status=if_else(frame == f,"Head estimated",status))
      
      
    }else{
      data <- data %>%
        mutate(status = if_else(head_to_be_estimated == "not yet","no head estimation possible",status)) %>%
        mutate(head_to_be_estimated = if_else(status == "no head estimation possible","NO", head_to_be_estimated)) %>%
        select(-distance_to_latest_head)
      return(data)
      break
      
    }
  }
}

skeleton_reorder <- function(data){
  if(!is.na(data[nrow(data),"is_head"])){
    data$index <- nrow(data):1
    data
  } else {
    data <- data
  }
}

##################

#get file path from command line
dataraw_file_path <- commandArgs(trailingOnly = TRUE)[1]
conversion_factor <- as.numeric(commandArgs(trailingOnly = TRUE)[2])
first_tp <- commandArgs(trailingOnly = TRUE)[3]
last_tp <- commandArgs(trailingOnly = TRUE)[4]

#timepoints to process
tps <- seq(first_tp,last_tp)

#create file path for saving
save_path <- file.path(dirname(dataraw_file_path),"skeletonized","unfiltered")
#create the save path directories
dir.create(save_path,recursive = TRUE)
#catch timelapses_metadata.txt location
toprocess_file_path <- file.path(file.path(dataraw_file_path, "toprocess_skeletonization.txt"))


#extract list of datasets to process from "timelapses_metadata.txt" file
list_of_datasets <- as.matrix(read.table(toprocess_file_path))
files_to_process <- paste0(paste0(file.path(dataraw_file_path,list_of_datasets),"_raw_data.rds"))
# print(files_to_process)


#load .rds with all experimental replicates
for (file in files_to_process){
  cat(paste0("\n\nimporting file: ", file))
  
  #get file title from raw dataset name
  file_title <- gsub("(.+)\\_raw_data.rds","\\1",basename(file))
  #get timepoints of this dataset that are already processed
  tps_processed <- gsub(".+timepoint_(\\d+)_skeletonized.+","\\1",grep(file_title, list.files(save_path,pattern="skeletonized"),value=TRUE))
  #get timepoints of this dataset that still have to be processed
  tps_to_process <- tps[!tps %in% tps_processed]
  
  cat(paste0("\nThe following timepoints are already analysed:\n"), sort(tps_processed))
  cat(paste0("\nThe following timepoints will be analysed:\n"),tps_to_process)
  
  #load dataset
  #but only if there are timepoints to be processed, otherwise go to next dataset
  if(!isempty(tps_to_process)){
    #dataset contains only timepoints that have not been processed yet
    data <- readRDS(file) %>%
      filter(tp %in% tps_to_process)
    
    annotation <- data %>%
      distinct(annotation) %>%
      pull(annotation)
    
    
    cat(paste0("\nWorking on ",annotation, " files."))
    
    
    #do the skeletonization for each timepoint individually
    for (timepoint in tps_to_process){
      
      cat(paste0("\n\nprocessing timepoint ", timepoint))
      
      data_skeletonized <- data %>%
        filter(tp == timepoint) %>%
        group_by(dataset_ID,tp,TrackID) %>%
        #guess direction from centroid movement for every Track
        group_modify(~ skeleton_direction(.x)) %>%
        group_by(dataset_ID, tp,TrackID,frame) %>%
        #skeletonization independently for every frame (this step takes time as skeletonization is happening one after the other)
        group_modify(~ skeleton_frame(.x),.keep=TRUE) %>%
        #guess head by choosing end pixel pointing in the moving direction (see above)
        group_modify(~ skeleton_head(.x)) %>%
        mutate(distance_to_latest_head = NA) %>%
        group_by(dataset_ID, tp,TrackID) %>%
        mutate(head_to_be_estimated = ifelse(grepl("downsampled|unclear",status),"YES","NO" )) %>%
        #head estimation based on head in closest frame
        group_modify(~ skeleton_head_estimate(.x)) %>%
        group_by(dataset_ID, tp,TrackID,frame) %>%
        #reorder so that head is always index == 1
        group_modify(~ skeleton_reorder(.x)) %>%
        group_by(dataset_ID,tp,TrackID,frame) %>%
        #all angles have to be between pi and -pi
        mutate(angle = ifelse(angle > pi & is.na(is_end), 2 * pi - angle,angle)) %>%
        mutate(angle = ifelse(angle < -pi & is.na(is_end), -2 * pi - angle,angle)) %>%
        ungroup() %>%
        mutate(annotation = annotation) %>%
        mutate(conversion_factor = conversion_factor)

      
      
      cat("\nskeletonization and head estimation done. now saving.")
      created_file_path <- file.path(save_path,paste0(gsub(" ", "_", annotation),"_timepoint_",timepoint,"_skeletonized.rds"))
      saveRDS(data_skeletonized, file = created_file_path)
      cat(paste0("\ndataset: ",annotation," timepoint ",timepoint, " was skeletonized \nand saved under: ", created_file_path))
      
      
      
    }
  }
  cat("\n DONE.")
}
